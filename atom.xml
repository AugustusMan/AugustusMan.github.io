<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一人静在书中</title>
  <subtitle>记录学习的技能和遇到的问题</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wang-yulong.github.io/"/>
  <updated>2017-07-12T16:47:13.392Z</updated>
  <id>https://wang-yulong.github.io/</id>
  
  <author>
    <name>王玉龙</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>&#39;struts2导入源文件&#39;</title>
    <link href="https://wang-yulong.github.io/2017/07/10/struts2%E5%AF%BC%E5%85%A5%E6%BA%90%E6%96%87%E4%BB%B6/"/>
    <id>https://wang-yulong.github.io/2017/07/10/struts2导入源文件/</id>
    <published>2017-07-10T12:13:49.000Z</published>
    <updated>2017-07-12T16:47:13.392Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1：查看xwork包下面的-ActionSupport"><a href="#1：查看xwork包下面的-ActionSupport" class="headerlink" title="1：查看xwork包下面的  ActionSupport"></a>1：查看xwork包下面的  ActionSupport</h2><p>   导入<br>   struts-2.3.16.3\src\xwork-core</p>
<h2 id="2：查看struts包下面的"><a href="#2：查看struts包下面的" class="headerlink" title="2：查看struts包下面的"></a>2：查看struts包下面的</h2><p>   导入 struts-2.3.16.3\src\core</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1：查看xwork包下面的-ActionSupport&quot;&gt;&lt;a href=&quot;#1：查看xwork包下面的-ActionSupport&quot; class=&quot;headerlink&quot; title=&quot;1：查看xwork包下面的  ActionSupport&quot;&gt;&lt;/a&gt;1：查看
    
    </summary>
    
    
      <category term="--struts2" scheme="https://wang-yulong.github.io/tags/struts2/"/>
    
  </entry>
  
  <entry>
    <title>struts2重定向传输汉字的问题</title>
    <link href="https://wang-yulong.github.io/2017/07/06/struts2%E9%87%8D%E5%AE%9A%E5%90%91%E4%BC%A0%E8%BE%93%E6%B1%89%E5%AD%97%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://wang-yulong.github.io/2017/07/06/struts2重定向传输汉字的问题/</id>
    <published>2017-07-06T11:42:37.000Z</published>
    <updated>2017-07-12T16:46:45.969Z</updated>
    
    <content type="html"><![CDATA[<p>##struts中的配置</p>
<pre><code>1)
&lt;package name=&quot;test1&quot; namespace=&quot;&quot; extends=&quot;struts-default&quot;&gt;
    &lt;action name=&quot;test1Action&quot; class=&quot;com.action.UserAction&quot; method=&quot;testAction&quot;&gt;
        &lt;result name=&quot;success&quot; type=&quot;redirect&quot; &gt;
            &lt;param name=&quot;location&quot;&gt;/showMsg.jsp?message=${message}&lt;/param&gt;
            &lt;param name=&quot;encode&quot;&gt;true&lt;/param&gt;
        &lt;/result&gt;
    &lt;/action&gt;
&lt;/package&gt;
 2）
 &lt;package name=&quot;test1&quot; namespace=&quot;&quot; extends=&quot;struts-default&quot;&gt;
    &lt;action name=&quot;test1Action&quot; class=&quot;com.action.UserAction&quot; method=&quot;testAction&quot;&gt;
        &lt;result name=&quot;success&quot; type=&quot;redirect&quot;&gt;/login.jsp?message=${message}&lt;/result&gt;
    &lt;/action&gt;
&lt;/package&gt;

两种都可以
</code></pre><p>##方案1</p>
<p>  修改tomcat安装目录下的config目录下server.xml</p>
<pre><code>针对8080和8089都增加参数  URIEncoding=&quot;UTF-8&quot;
</code></pre><p>  action中</p>
<p>   public String testAction() throws UnsupportedEncodingException<br>    {</p>
<pre><code>    setMessage(&quot;el 表达式中文测试 test&quot;);

    return &quot;success&quot;;
}
...get/set方法 message
</code></pre><p>##方案2</p>
<pre><code>   在action中对汉字进行编码，在jsp页面中进行解码，具体如下

1）action中

   private String message;

public String testAction() throws UnsupportedEncodingException
{

    setMessage(URLEncoder.encode(&quot;el 表达式中文测试 test&quot;,&quot;UTF-8&quot;));

    return &quot;success&quot;;
}

...get/set方法 message

2）jsp中
    &lt;% 
           String userName= request.getParameter(&quot;message&quot;);
         userName=new String(userName.getBytes(&quot;iso8859-1&quot;),&quot;UTF-8&quot;);
            // userName=URLDecoder.decode(userName,&quot;UTF-8&quot;);  实测不加也可以
            out.println(message);
    %&gt;

感觉方案1比较好，但是如果不方便修改服务器配置的话，第二种也可以，就是代码有点累赘
</code></pre><p>##扩展（tomcat的端口的简单描述）</p>
<pre><code>8080：http端口
8443：https端口
8005：远程停服务器端口 &lt;Server port=&quot;8005&quot; shutdown=&quot;SHUTDOWN&quot;&gt;
8009：AJP端口  
     AJP（Apache JServ Protocol）是定向包协议。因为性能原因，使用二进制格式来传输可读性文本。WEB服务器通过 TCP连接 和 SERVLET容器连接。
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;##struts中的配置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1)
&amp;lt;package name=&amp;quot;test1&amp;quot; namespace=&amp;quot;&amp;quot; extends=&amp;quot;struts-default&amp;quot;&amp;gt;
    &amp;lt;a
    
    </summary>
    
    
      <category term="-struts2" scheme="https://wang-yulong.github.io/tags/struts2/"/>
    
  </entry>
  
  <entry>
    <title>mysql建表不能用作变量名称的</title>
    <link href="https://wang-yulong.github.io/2017/06/30/mysql%E5%BB%BA%E8%A1%A8%E4%B8%8D%E8%83%BD%E7%94%A8%E4%BD%9C%E5%8F%98%E9%87%8F%E5%90%8D%E7%A7%B0%E7%9A%84/"/>
    <id>https://wang-yulong.github.io/2017/06/30/mysql建表不能用作变量名称的/</id>
    <published>2017-06-30T04:33:04.000Z</published>
    <updated>2017-07-12T16:37:34.880Z</updated>
    
    <content type="html"><![CDATA[<h2 id="mysql-建表的时候这些词不能当做列名，否则批接sql串查询的时候会有一些莫名其妙的问题，此处只是用于记录；"><a href="#mysql-建表的时候这些词不能当做列名，否则批接sql串查询的时候会有一些莫名其妙的问题，此处只是用于记录；" class="headerlink" title="mysql 建表的时候这些词不能当做列名，否则批接sql串查询的时候会有一些莫名其妙的问题，此处只是用于记录；"></a>mysql 建表的时候这些词不能当做列名，否则批接sql串查询的时候会有一些莫名其妙的问题，此处只是用于记录；</h2><h3 id="1-index"><a href="#1-index" class="headerlink" title="1 index"></a>1 index</h3><h3 id="2-key"><a href="#2-key" class="headerlink" title="2 key"></a>2 key</h3>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;mysql-建表的时候这些词不能当做列名，否则批接sql串查询的时候会有一些莫名其妙的问题，此处只是用于记录；&quot;&gt;&lt;a href=&quot;#mysql-建表的时候这些词不能当做列名，否则批接sql串查询的时候会有一些莫名其妙的问题，此处只是用于记录；&quot; class=&quot;h
    
    </summary>
    
    
      <category term="mysql" scheme="https://wang-yulong.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql用法总结</title>
    <link href="https://wang-yulong.github.io/2017/06/27/mysql%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>https://wang-yulong.github.io/2017/06/27/mysql用法总结/</id>
    <published>2017-06-27T08:24:40.000Z</published>
    <updated>2017-07-12T16:39:57.937Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-mysql建表，带时间戳"><a href="#1-mysql建表，带时间戳" class="headerlink" title="1:mysql建表，带时间戳"></a>1:mysql建表，带时间戳</h2><pre><code>DROP TABLE IF EXISTS `CONTENT`;
CREATE TABLE `CONTENT` (
  `ID` char(20) NOT NULL,
  `CURRENT_TIME` timestamp not null default current_timestamp,
  PRIMARY KEY (`ID`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

存储引擎是innodb。nnoDB 是 MySQL 上第一个提供外键约束的数据存储引擎，除了提供事务处理外，InnoDB 还支持行锁，提供和 Oracle 一样的一致性的不加锁读取，能增加并发读的用户数量并提高性能，不会增加锁的数量。InnoDB 的设计目标是处理大容量数据时最大化性能，它的 CPU 利用率是其他所有基于磁盘的关系数据库引擎中最有效率的。
InnoDB 是一套放在 MySQL 后台的完整数据库系统，InnoDB 有它自己的缓冲池，能缓冲数据和索引，InnoDB 还把数据和索引存放在表空间里面，可能包含好几个文件，这和 MyISAM 表完全不同，在 MyISAM 中，表被存放在单独的文件中，InnoDB 表的大小只受限于操作系统文件的大小，一般为 2GB。
</code></pre><h2 id="2-mysql导出建表语句"><a href="#2-mysql导出建表语句" class="headerlink" title="2: mysql导出建表语句"></a>2: mysql导出建表语句</h2><pre><code>数据库-&gt;右键-&gt;转储为SQL（1）
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-mysql建表，带时间戳&quot;&gt;&lt;a href=&quot;#1-mysql建表，带时间戳&quot; class=&quot;headerlink&quot; title=&quot;1:mysql建表，带时间戳&quot;&gt;&lt;/a&gt;1:mysql建表，带时间戳&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;DROP TABLE IF 
    
    </summary>
    
    
      <category term="mysql" scheme="https://wang-yulong.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>&#39;html常见问题&#39;</title>
    <link href="https://wang-yulong.github.io/2017/06/27/html%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>https://wang-yulong.github.io/2017/06/27/html常见问题/</id>
    <published>2017-06-27T07:12:26.000Z</published>
    <updated>2017-06-29T06:36:28.787Z</updated>
    
    <content type="html"><![CDATA[<p>##1 :$.ajax返回一个对象</p>
<pre><code>客户端：
$.ajax({
    type:&quot;Get&quot;,
    url:&quot;CommonServlet&quot;,
    data:
        {
            functionName:&quot;&lt;%=RequestConst.QuerySingleTemplate %&gt;&quot;,
            templateId:$(&quot;#sel&quot;).val(),
        },
    dataType:&quot;json&quot;,
    success:function(obj)
    {
        //var template=eval(obj);
        //alert(&quot;12423&quot;);
        alert(obj.url);
        //$(&quot;#templateUrl&quot;).val(template.url);
    }
});
服务端:

response.getWriter().print(JSONObject.fromObject(templateInfo));
</code></pre><p>##2 eval(“3*10”)执行表达式的内容</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;##1 :$.ajax返回一个对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;客户端：
$.ajax({
    type:&amp;quot;Get&amp;quot;,
    url:&amp;quot;CommonServlet&amp;quot;,
    data:
        {
         
    
    </summary>
    
    
      <category term="html" scheme="https://wang-yulong.github.io/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>&#39;jsp乱码总结&#39;</title>
    <link href="https://wang-yulong.github.io/2017/06/27/jsp%E4%B9%B1%E7%A0%81%E6%80%BB%E7%BB%93/"/>
    <id>https://wang-yulong.github.io/2017/06/27/jsp乱码总结/</id>
    <published>2017-06-27T06:53:46.000Z</published>
    <updated>2017-07-12T16:34:17.330Z</updated>
    
    <content type="html"><![CDATA[<h2 id="java-web项目乱码的常用解决方法"><a href="#java-web项目乱码的常用解决方法" class="headerlink" title="java web项目乱码的常用解决方法"></a>java web项目乱码的常用解决方法</h2><ol>
<li>request.setCharetEncoding(“utf-8”);</li>
<li>response.setCharerEncoding(“utf-8”);</li>
<li>response.setContextType(“text/html;charset=utf-8”);</li>
<li>如果是request.getParameter(“参数名称”)获取中文乱码</li>
</ol>
<pre><code>String keyCodeStr=request.getParameter(&quot;keyCodeStr&quot;);

keyCodeStr= new String(keyCodeStr.getBytes(&quot;ISO8851-1&quot;),&quot;utf-8&quot;);
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;java-web项目乱码的常用解决方法&quot;&gt;&lt;a href=&quot;#java-web项目乱码的常用解决方法&quot; class=&quot;headerlink&quot; title=&quot;java web项目乱码的常用解决方法&quot;&gt;&lt;/a&gt;java web项目乱码的常用解决方法&lt;/h2&gt;&lt;ol&gt;

    
    </summary>
    
    
      <category term="java" scheme="https://wang-yulong.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>hexo开启rss报错原因记录</title>
    <link href="https://wang-yulong.github.io/2017/06/25/rss%E6%8A%A5%E9%94%99%E5%8E%9F%E5%9B%A0%E8%AE%B0%E5%BD%95/"/>
    <id>https://wang-yulong.github.io/2017/06/25/rss报错原因记录/</id>
    <published>2017-06-25T03:25:05.000Z</published>
    <updated>2017-07-12T16:46:08.718Z</updated>
    
    <content type="html"><![CDATA[<p>打开Rss报错如图</p>
<p>Input is not proper UTF-8, indicate encoding </p>
<p>原因可能如下：</p>
<ol>
<li>使用了特殊字串”:”(冒号中文的)</li>
<li>使用了#号</li>
</ol>
<p>参考：<br>     <a href="http://blog.csdn.net/isaisai/article/details/53899089" target="_blank" rel="external">http://blog.csdn.net/isaisai/article/details/53899089</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;打开Rss报错如图&lt;/p&gt;
&lt;p&gt;Input is not proper UTF-8, indicate encoding &lt;/p&gt;
&lt;p&gt;原因可能如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用了特殊字串”:”(冒号中文的)&lt;/li&gt;
&lt;li&gt;使用了#号&lt;/li&gt;
&lt;/ol&gt;
&lt;p
    
    </summary>
    
    
      <category term="工具类" scheme="https://wang-yulong.github.io/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>myeclipse常用快捷键</title>
    <link href="https://wang-yulong.github.io/2017/06/22/myeclipse%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>https://wang-yulong.github.io/2017/06/22/myeclipse常用快捷键/</id>
    <published>2017-06-22T08:41:38.000Z</published>
    <updated>2017-07-12T16:44:38.805Z</updated>
    
    <content type="html"><![CDATA[<p>##Myeclipse常用快捷键标记</p>
<p>1：Ctrl+H 搜索整个项目</p>
<p>2：Ctrl+Shift+O  导包</p>
<p>3：Alt+Shift+S   快捷实现接口，get/set方法，构造函数等</p>
<p>4：Alt+Shift+J  快速注释（需要选中函数或者属性名称）</p>
<p>5:Alt+←  或者 Alt+→  到上一步或者下一步位置</p>
<p>6 显示行号  windows-&gt;preferences-&gt;general-&gt;editors-&gt;Text Editer-&gt;show line numbers</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;##Myeclipse常用快捷键标记&lt;/p&gt;
&lt;p&gt;1：Ctrl+H 搜索整个项目&lt;/p&gt;
&lt;p&gt;2：Ctrl+Shift+O  导包&lt;/p&gt;
&lt;p&gt;3：Alt+Shift+S   快捷实现接口，get/set方法，构造函数等&lt;/p&gt;
&lt;p&gt;4：Alt+Shift+J  快
    
    </summary>
    
    
      <category term="工具类" scheme="https://wang-yulong.github.io/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>mysql绿色版安装步骤</title>
    <link href="https://wang-yulong.github.io/2017/06/21/mysql%E5%AE%89%E8%A3%85/"/>
    <id>https://wang-yulong.github.io/2017/06/21/mysql安装/</id>
    <published>2017-06-21T12:11:52.000Z</published>
    <updated>2017-07-23T03:39:48.995Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-在官网下载https-dev-mysql-com-downloads-mysql-（如图）"><a href="#1-在官网下载https-dev-mysql-com-downloads-mysql-（如图）" class="headerlink" title="1:在官网下载https://dev.mysql.com/downloads/mysql/（如图）"></a>1:在官网下载<a href="https://dev.mysql.com/downloads/mysql/（如图）" target="_blank" rel="external">https://dev.mysql.com/downloads/mysql/（如图）</a></h2><p><img src="/img/mysql1.png" alt="图片"></p>
<h2 id="2-解压之后，首先在解决的当前目录下添加my-ini文件-内容如下"><a href="#2-解压之后，首先在解决的当前目录下添加my-ini文件-内容如下" class="headerlink" title="2:解压之后，首先在解决的当前目录下添加my.ini文件(内容如下)"></a>2:解压之后，首先在解决的当前目录下添加my.ini文件(内容如下)</h2><pre><code>[client]
port=3306
default-character-set=utf8

[mysqld] 
# 设置为MYSQL的安装目录 
basedir=E:\mysql-5.7.18-winx64
# 设置为MYSQL的数据目录 
datadir=E:\mysql-5.7.18-winx64\data
port=3306
character_set_server=utf8
sql_mode=NO_ENGINE_SUBSTITUTION,NO_AUTO_CREATE_USER
#开启查询缓存
explicit_defaults_for_timestamp=true
</code></pre><h2 id="3-cd-切到解压目录-bin-依次执行如下命令"><a href="#3-cd-切到解压目录-bin-依次执行如下命令" class="headerlink" title="3:(cd 切到解压目录/bin)依次执行如下命令"></a>3:(cd 切到解压目录/bin)依次执行如下命令</h2><ol>
<li><p>注册MySql服务</p>
<p> mysqld -install</p>
</li>
<li><p>初始化Mysql的数据表(这一步可能会生成一个临时密码，记得保存)</p>
<p> mysqld –initialize –user=mysql –console</p>
</li>
<li><p>启动Mysql</p>
<p> net start mysql</p>
</li>
<li><p>修改初始密码 </p>
<p> step 1: SET PASSWORD = PASSWORD(‘your new password’);//初始化密码</p>
<p> step 2: ALTER USER ‘root’@’localhost’ PASSWORD EXPIRE NEVER;//设置密码用不过期</p>
<p> step 3: flush privileges;//设置用户或更改密码后需用flush privileges刷新MySQL的系统权限相关表，否则会出现拒绝访问，还有一种方法，就是重新启动mysql服务器，来使新设置生效。<br>­</p>
</li>
<li><p>附加（可选）</p>
<p> **可以配置 MySQL_HOME=”你的安装路径”  Path 添加 %MySQL_HOME%/bin;</p>
<p> 好处是启动mysql服务的时候（net start mysql）不用在 cd ..切到到mysql目录了**</p>
</li>
</ol>
<p>##4:常见问题<br>     (1) mysqld -install 结果Install/Remove of the Service Denied!<br>         解决方案：进入 C:\Window\System32  找到CMD.EXE 右键选择 以管理员身份 进行，再进入相应目录执行命令，一切就OK了。<br>     (2)执行报错 应用程序无法正常启动（0x000007b） 如图</p>
<p><img src="/img/mysql2.png" alt="图片">  </p>
<pre><code>解决方案：可以使用如何使用DirectX修复工具进行修复
</code></pre><p>详细可查看 <a href="http://jingyan.baidu.com/article/ed2a5d1f57a1ab09f6be17d8.html" target="_blank" rel="external">http://jingyan.baidu.com/article/ed2a5d1f57a1ab09f6be17d8.html</a></p>
<pre><code>(3) 部署java web项目到服务器，老是提示“java.sql.SQLException: No suitable driver found for jdbc:mysql”

    1.查了好久发现是,java web项目虽然成功部署了，但是mysql-connector-java-3.1.14-bin.jar并没有复制到
      “webapps\WeixinCoreServlet\WEB-INF\lib ”该目录下，导包的方式是bulid_path那样导的，虽然导入成功了，
      但是并不复制，必须手动刷新（右键项目-&gt;刷新(F5)）myelipse 2014下发生的

（4）执行查询报错 Host &apos;XXX&apos; is not allowed to connect to this MySQL server 
      原因：未授权远程账号
      解决方案：
      1.在 Windows 主机中点击开始菜单，运行，输入“cmd”，进入控制台，然后cd 进入MySQL 的 bin 目录下，然后输入下面的命令。
           mysql -uroot -p123456                 (123456 为 root 用户的密码。)
      2.创建远程登陆用户并授权
           grant all PRIVILEGES on test_db.* to root@&apos;192.168.1.101&apos;  identified by &apos;123456&apos;;
</code></pre><p> 引用：<a href="http://www.cnblogs.com/zhangzhu/archive/2013/08/22/3274831.html" target="_blank" rel="external">http://www.cnblogs.com/zhangzhu/archive/2013/08/22/3274831.html</a></p>
<pre><code>(5)mysql  运行时报错（如下）

   Establishing SSL connection without server&apos;s identity verification is not recommended.
   You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification.
   原因分析：mysql高版本需要指明是否安全连接
   解决方案：（mysql的连接串改为如下配置）
   “ jbbcLmysql://localhost:3306/weixin?characterEncoding=utf8&amp;useSSL=true ”
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-在官网下载https-dev-mysql-com-downloads-mysql-（如图）&quot;&gt;&lt;a href=&quot;#1-在官网下载https-dev-mysql-com-downloads-mysql-（如图）&quot; class=&quot;headerlink&quot; title
    
    </summary>
    
      <category term="MySql" scheme="https://wang-yulong.github.io/categories/MySql/"/>
    
    
      <category term="mysql" scheme="https://wang-yulong.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb(开发微信公众账号)微信开发遇到的问题</title>
    <link href="https://wang-yulong.github.io/2017/06/20/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://wang-yulong.github.io/2017/06/20/微信开发遇到的问题/</id>
    <published>2017-06-20T12:22:54.000Z</published>
    <updated>2017-07-12T16:33:40.772Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1：回复消息老是提示”该公众号暂时无法提供服务，请稍后再试”"><a href="#1：回复消息老是提示”该公众号暂时无法提供服务，请稍后再试”" class="headerlink" title="1：回复消息老是提示”该公众号暂时无法提供服务，请稍后再试”"></a>1：回复消息老是提示”该公众号暂时无法提供服务，请稍后再试”</h2><pre><code>查了好久，发现并不是网上说的返回值为空的为题，而是web.xml中
servelt的映射路径写错了。。如图所示
</code></pre><p><img src="/img/weixin1.png" alt="图片"></p>
<h2 id="2-本地调试环境的配置"><a href="#2-本地调试环境的配置" class="headerlink" title="2: 本地调试环境的配置"></a>2: 本地调试环境的配置</h2><pre><code>1：下载ngrok  （https://dashboard.ngrok.com）
2: 注册获取  （authtoken) 
3: 运行ngrok.exe
4: 执行 ngrok authtoken 5x5JMF92LuLTfXaT8YA7N_6mMqPvzAKyircey21JHW2(注册生成的authtoken)
5: 执行 ngrok http 8080
</code></pre><p>如图 可生成如此结果</p>
<p><img src="/img/weixin2.png" alt="图片"></p>
<p>此时在微信公众平台进行填入上面红色框内的内容，进行重新映射</p>
<p><img src="/img/weixin3.png" alt="图片"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1：回复消息老是提示”该公众号暂时无法提供服务，请稍后再试”&quot;&gt;&lt;a href=&quot;#1：回复消息老是提示”该公众号暂时无法提供服务，请稍后再试”&quot; class=&quot;headerlink&quot; title=&quot;1：回复消息老是提示”该公众号暂时无法提供服务，请稍后再试”&quot;&gt;
    
    </summary>
    
    
      <category term="微信" scheme="https://wang-yulong.github.io/tags/%E5%BE%AE%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>C#_封装之（List与Dictionary）</title>
    <link href="https://wang-yulong.github.io/2017/06/09/C-sharp%E5%B0%81%E8%A3%85%EF%BC%88List%E4%B8%8EDictionary%EF%BC%89/"/>
    <id>https://wang-yulong.github.io/2017/06/09/C-sharp封装（List与Dictionary）/</id>
    <published>2017-06-09T12:30:43.000Z</published>
    <updated>2017-07-12T16:51:34.437Z</updated>
    
    <content type="html"><![CDATA[<p>##简单描述</p>
<p>KeyedList:</p>
<pre><code>  同时实现IDictionary和IList接口的集合。

  带有索引的List使用上会比较方便，可以通过Key来索引Value的。

同时内部是线性存储的，可以保证顺序，可以使用下标访问数据。

内部使用Dictionary来存储Key到Value的映射，

List存储KeyValuePair。有很大的冗余，可以参考（小规模的数据用着还是比较方便的）
</code></pre><p>代码:</p>
<pre><code>  [Serializable]
[Obsolete(&quot;未完善，有冗余&quot;)]
public sealed class KeyedList&lt;TKey, TValue&gt; : 
    IDictionary&lt;TKey, TValue&gt;, 
    IList&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;
{
    private readonly Dictionary&lt;TKey, TValue&gt; _dict = new Dictionary&lt;TKey, TValue&gt;();
    private readonly List&lt;KeyValuePair&lt;TKey, TValue&gt;&gt; _list = new List&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;();

    /// &lt;summary&gt;
    /// Returns false.
    /// &lt;/summary&gt;
    public bool IsReadOnly
    {
        get { return false; }
    }

    /// &lt;summary&gt;
    /// Returns the number of entries in the KeyedList.
    /// &lt;/summary&gt;
    public int Count
    {
        get { return _list.Count; }
    }

    /// &lt;summary&gt;
    /// Get/Set the value at the specified index.
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;index&quot;&gt;The index.&lt;/param&gt;
    /// &lt;returns&gt;The value.&lt;/returns&gt;
    public KeyValuePair&lt;TKey, TValue&gt; this[int index]
    {
        get
        {
            if (index &lt; 0 || index &gt;= Count)
            {
                throw new ArgumentOutOfRangeException(&quot;index&quot;);
            }

            return _list[index];
        }
        set
        {
            if (index &lt; 0 || index &gt;= Count)
            {
                throw new ArgumentOutOfRangeException(&quot;index&quot;);
            }

            _list[index] = value;
            _dict[value.Key] = value.Value;
        }
    }

    /// &lt;summary&gt;
    /// Get/Set the value associated with the specified key.
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;key&quot;&gt;The key.&lt;/param&gt;
    /// &lt;returns&gt;The associated value.&lt;/returns&gt;
    public TValue this[TKey key]
    {
        get { return _dict[key]; }
        set
        {
            if (_dict.ContainsKey(key))
            {
                _dict[key] = value;
                _list[IndexOf(key)] = new KeyValuePair&lt;TKey, TValue&gt;(key, value);
            }
            else
            {
                Add(key, value);
            }
        }
    }

    /// &lt;summary&gt;
    /// Get an unordered list of keys.
    /// This collection refers back to the keys in the original Dictionary.
    /// &lt;/summary&gt;
    public ICollection&lt;TKey&gt; Keys
    {
        get { return _dict.Keys; }
    }

    /// &lt;summary&gt;
    /// Get an unordered list of values.
    /// This collection refers back to the values in the original Dictionary.
    /// &lt;/summary&gt;
    public ICollection&lt;TValue&gt; Values
    {
        get { return _dict.Values; }
    }

    /// &lt;summary&gt;
    /// Get the ordered list of keys.
    /// This is a copy of the keys in the original Dictionary.
    /// &lt;/summary&gt;
    public List&lt;TKey&gt; OrderedKeys
    {
        get
        {
            List&lt;TKey&gt; retList = new List&lt;TKey&gt;();

            foreach (KeyValuePair&lt;TKey, TValue&gt; kvp in _list)
            {
                retList.Add(kvp.Key);
            }

            return retList;
        }
    }

    /// &lt;summary&gt;
    /// Get the ordered list of values.
    /// This is a copy of the values in the original Dictionary.
    /// &lt;/summary&gt;
    public List&lt;TValue&gt; OrderedValues
    {
        get
        {
            List&lt;TValue&gt; retList = new List&lt;TValue&gt;();

            foreach (KeyValuePair&lt;TKey, TValue&gt; kvp in _list)
            {
                retList.Add(kvp.Value);
            }

            return retList;
        }
    }

    /// &lt;summary&gt;
    /// Returns the key at the specified index.
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;idx&quot;&gt;The index.&lt;/param&gt;
    /// &lt;returns&gt;The key at the index.&lt;/returns&gt;
    public TKey GetKey(int idx)
    {
        if (idx &lt; 0 || idx &gt;= Count)
        {
            throw new ArgumentOutOfRangeException(&quot;index&quot;);
        }

        return _list[idx].Key;
    }

    /// &lt;summary&gt;
    /// Returns the value at the specified index.
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;idx&quot;&gt;The index.&lt;/param&gt;
    /// &lt;returns&gt;The value at the index.&lt;/returns&gt;
    public TValue GetValue(int idx)
    {
        if (idx &lt; 0 || idx &gt;= Count)
        {
            throw new ArgumentOutOfRangeException(&quot;index&quot;);
        }

        return _list[idx].Value;
    }

    /// &lt;summary&gt;
    /// Get the index of a particular key.
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;key&quot;&gt;The key to find the index of.&lt;/param&gt;
    /// &lt;returns&gt;The index of the key, or -1 if not found.&lt;/returns&gt;
    public int IndexOf(TKey key)
    {
        int ret = -1;

        for (int i = 0; i &lt; _list.Count; i++)
        {
            if (_list[i].Key.Equals(key))
            {
                ret = i;
                break;
            }
        }

        return ret;
    }

    /// &lt;summary&gt;
    /// Given the key-value pair, find the index.
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;kvp&quot;&gt;The key-value pair.&lt;/param&gt;
    /// &lt;returns&gt;The index, or -1 if not found.&lt;/returns&gt;
    public int IndexOf(KeyValuePair&lt;TKey, TValue&gt; kvp)
    {
        return IndexOf(kvp.Key);
    }

    /// &lt;summary&gt;
    /// Gets the Dictionary class backing the KeyedList.
    /// &lt;/summary&gt;
    public Dictionary&lt;TKey, TValue&gt; ObjectTable
    {
        get { return _dict; }
    }

    /// &lt;summary&gt;
    /// Clears all entries in the KeyedList.
    /// &lt;/summary&gt;
    public void Clear()
    {
        _dict.Clear();
        _list.Clear();
    }

    /// &lt;summary&gt;
    /// Test if the KeyedList contains the key.
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;key&quot;&gt;The key.&lt;/param&gt;
    /// &lt;returns&gt;True if the key is found.&lt;/returns&gt;
    public bool ContainsKey(TKey key)
    {
        return _dict.ContainsKey(key);
    }

    /// &lt;summary&gt;
    /// Test if the KeyedList contains the key in the key-value pair.
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;kvp&quot;&gt;The key-value pair.&lt;/param&gt;
    /// &lt;returns&gt;True if the key is found.&lt;/returns&gt;
    public bool Contains(KeyValuePair&lt;TKey, TValue&gt; kvp)
    {
        return _dict.ContainsKey(kvp.Key);
    }

    /// &lt;summary&gt;
    /// Adds a key-value pair to the KeyedList.
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;key&quot;&gt;The key.&lt;/param&gt;
    /// &lt;param name=&quot;value&quot;&gt;The associated value.&lt;/param&gt;
    public void Add(TKey key, TValue value)
    {
        _dict.Add(key, value);
        _list.Add(new KeyValuePair&lt;TKey, TValue&gt;(key, value));
    }

    /// &lt;summary&gt;
    /// Adds a key-value pair to the KeyedList.
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;kvp&quot;&gt;The KeyValuePair instance.&lt;/param&gt;
    public void Add(KeyValuePair&lt;TKey, TValue&gt; kvp)
    {
        Add(kvp.Key, kvp.Value);
    }

    /// &lt;summary&gt;
    /// Copy the entire key-value pairs to the KeyValuePair array, starting
    /// at the specified index of the target array.  The array is populated 
    /// as an ordered list.
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;kvpa&quot;&gt;The KeyValuePair array.&lt;/param&gt;
    /// &lt;param name=&quot;idx&quot;&gt;The position to start the copy.&lt;/param&gt;
    public void CopyTo(KeyValuePair&lt;TKey, TValue&gt;[] kvpa, int idx)
    {
        _list.CopyTo(kvpa, idx);
    }

    /// &lt;summary&gt;
    /// Insert the key-value at the specified index.
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;idx&quot;&gt;The zero-based insert point.&lt;/param&gt;
    /// &lt;param name=&quot;key&quot;&gt;The key.&lt;/param&gt;
    /// &lt;param name=&quot;value&quot;&gt;The value.&lt;/param&gt;
    public void Insert(int idx, TKey key, TValue value)
    {
        if ((idx &lt; 0) || (idx &gt; Count))
        {
            throw new ArgumentOutOfRangeException(&quot;index&quot;);
        }

        _dict.Add(key, value);
        _list.Insert(idx, new KeyValuePair&lt;TKey, TValue&gt;(key, value));
    }

    /// &lt;summary&gt;
    /// Insert the key-value pair at the specified index location.
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;idx&quot;&gt;The key.&lt;/param&gt;
    /// &lt;param name=&quot;kvp&quot;&gt;The value.&lt;/param&gt;
    public void Insert(int idx, KeyValuePair&lt;TKey, TValue&gt; kvp)
    {
        if ((idx &lt; 0) || (idx &gt; Count))
        {
            throw new ArgumentOutOfRangeException(&quot;index&quot;);
        }

        _dict.Add(kvp.Key, kvp.Value);
        _list.Insert(idx, kvp);
    }

    /// &lt;summary&gt;
    /// Remove the entry.
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;key&quot;&gt;The key identifying the key-value pair.&lt;/param&gt;
    /// &lt;returns&gt;True if removed.&lt;/returns&gt;
    public bool Remove(TKey key)
    {
        bool found = _dict.Remove(key);

        if (found)
        {
            _list.RemoveAt(IndexOf(key));
        }

        return found;
    }

    /// &lt;summary&gt;
    /// Remove the key in the specified KeyValuePair instance.  The Value
    /// property is ignored.
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;kvp&quot;&gt;The key-value identifying the entry.&lt;/param&gt;
    /// &lt;returns&gt;True if removed.&lt;/returns&gt;
    public bool Remove(KeyValuePair&lt;TKey, TValue&gt; kvp)
    {
        return Remove(kvp.Key);
    }

    /// &lt;summary&gt;
    /// Remove the entry at the specified index.
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;idx&quot;&gt;The index to the entry to be removed.&lt;/param&gt;
    public void RemoveAt(int idx)
    {
        if ((idx &lt; 0) || (idx &gt;= Count))
        {
            throw new ArgumentOutOfRangeException(&quot;index&quot;);
        }

        _dict.Remove(_list[idx].Key);
        _list.RemoveAt(idx);
    }

    /// &lt;summary&gt;
    /// Attempt to get the value, given the key, without throwing an exception if not found.
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;key&quot;&gt;The key indentifying the entry.&lt;/param&gt;
    /// &lt;param name=&quot;val&quot;&gt;The value, if found.&lt;/param&gt;
    /// &lt;returns&gt;True if found.&lt;/returns&gt;
    public bool TryGetValue(TKey key, out TValue val)
    {
        return _dict.TryGetValue(key, out val);
    }

    /// &lt;summary&gt;
    /// Returns an ordered System.Collections KeyValuePair objects.
    /// &lt;/summary&gt;
    IEnumerator IEnumerable.GetEnumerator()
    {
        return _list.GetEnumerator();
    }

    /// &lt;summary&gt;
    /// Returns an ordered KeyValuePair enumerator.
    /// &lt;/summary&gt;
    IEnumerator&lt;KeyValuePair&lt;TKey, TValue&gt;&gt; IEnumerable&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;.GetEnumerator()
    {
        return _list.GetEnumerator();
    }
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;##简单描述&lt;/p&gt;
&lt;p&gt;KeyedList:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  同时实现IDictionary和IList接口的集合。

  带有索引的List使用上会比较方便，可以通过Key来索引Value的。

同时内部是线性存储的，可以保证顺序，可以使用下标访问数
    
    </summary>
    
    
      <category term="c#" scheme="https://wang-yulong.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>c# GDI测量某个点在某个不规则路径上或路径中</title>
    <link href="https://wang-yulong.github.io/2017/05/23/c-%E6%B5%8B%E9%87%8F%E7%B1%BB/"/>
    <id>https://wang-yulong.github.io/2017/05/23/c-测量类/</id>
    <published>2017-05-23T07:07:36.000Z</published>
    <updated>2017-07-12T16:43:25.007Z</updated>
    
    <content type="html"><![CDATA[<p>#测量某个点是否在不规则路径上</p>
<h2 id="1：对路径进行克隆（防止当前的操作影响所要渲染的路径）"><a href="#1：对路径进行克隆（防止当前的操作影响所要渲染的路径）" class="headerlink" title="1：对路径进行克隆（防止当前的操作影响所要渲染的路径）"></a>1：对路径进行克隆（防止当前的操作影响所要渲染的路径）</h2><pre><code>bool isExist=false;

var path = (GraphicsPath)_path.Clone();
</code></pre><h2 id="2：-创建Matrix对象（3-3的矩阵），用来对该路径进行平移（TransLate），缩放（Scale），旋转（Rotate）"><a href="#2：-创建Matrix对象（3-3的矩阵），用来对该路径进行平移（TransLate），缩放（Scale），旋转（Rotate）" class="headerlink" title="2： 创建Matrix对象（3*3的矩阵），用来对该路径进行平移（TransLate），缩放（Scale），旋转（Rotate）"></a>2： 创建Matrix对象（3*3的矩阵），用来对该路径进行平移（TransLate），缩放（Scale），旋转（Rotate）</h2><pre><code> Matrix matrix = new Matrix();
matrix.Translate(this.Location.X, this.Location.Y);
path.Transform(matrix);
</code></pre><h2 id="3-用画笔为路径增加轮廓（因为GraphicsPath本来起始是没有空间，也就无从谈起是否落在该路径上）"><a href="#3-用画笔为路径增加轮廓（因为GraphicsPath本来起始是没有空间，也就无从谈起是否落在该路径上）" class="headerlink" title="3:用画笔为路径增加轮廓（因为GraphicsPath本来起始是没有空间，也就无从谈起是否落在该路径上）"></a>3:用画笔为路径增加轮廓（因为GraphicsPath本来起始是没有空间，也就无从谈起是否落在该路径上）</h2><pre><code>using (var pen = new Pen(Color.FromArgb(0, 153, 229), 6))
  {
      path.Widen(pen);
  }
</code></pre><h2 id="4：判断改点是否在路径上"><a href="#4：判断改点是否在路径上" class="headerlink" title="4：判断改点是否在路径上"></a>4：判断改点是否在路径上</h2><pre><code>if (path.IsVisible(pt))
  {
      isExist = true;
  }
</code></pre><p>   通过以上4步便可以知道某个点是不是在不规则路径上</p>
<h1 id="测量某个点是否在不规则路径中"><a href="#测量某个点是否在不规则路径中" class="headerlink" title="测量某个点是否在不规则路径中"></a>测量某个点是否在不规则路径中</h1><p>## </p>
<pre><code>    GraphicsPath path = new GraphicsPath();
  // 指示由矩形和由路径构成的图形形状的内部。无法继承此类。
  Region myRegion = new Region();             
  myGraphicsPath.Reset();
  Point inputpoint1 = new Point(inputx1, inputy1);
  Point inputpoint2 = new Point(inputx2, inputy2);

  myGraphicsPath.AddPolygon(inputpoint1);
  myGraphicsPath.AddPolygon(inputpoint2);
  myRegion.MakeEmpty();

  myRegion.Union(myGraphicsPath); 

//返回判断点是否在不规则路径中
bool result= myRegion.IsVisible(inputponint);
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;#测量某个点是否在不规则路径上&lt;/p&gt;
&lt;h2 id=&quot;1：对路径进行克隆（防止当前的操作影响所要渲染的路径）&quot;&gt;&lt;a href=&quot;#1：对路径进行克隆（防止当前的操作影响所要渲染的路径）&quot; class=&quot;headerlink&quot; title=&quot;1：对路径进行克隆（防止当前的
    
    </summary>
    
    
      <category term="c#" scheme="https://wang-yulong.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>c# invoke和BeginInvoke 细节收录</title>
    <link href="https://wang-yulong.github.io/2017/05/05/c-invoke%E5%92%8CBeginInvoke-%E7%BB%86%E8%8A%82%E6%94%B6%E5%BD%95/"/>
    <id>https://wang-yulong.github.io/2017/05/05/c-invoke和BeginInvoke-细节收录/</id>
    <published>2017-05-05T12:34:08.000Z</published>
    <updated>2017-07-12T16:42:14.139Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Invoke"><a href="#Invoke" class="headerlink" title="Invoke"></a>Invoke</h1><ol>
<li><p>MSDN的解释</p>
<p> 在拥有此控件的基础窗口句柄的线程上执行指定的委托</p>
</li>
<li><p>自我理解</p>
<p> （1）同步的，必须得等委托内的代码执行完成之后才能执行</p>
</li>
</ol>
<h1 id="BeginInvoke"><a href="#BeginInvoke" class="headerlink" title="BeginInvoke"></a>BeginInvoke</h1><ol>
<li>MSDN的解释</li>
</ol>
<pre><code>在创建控件的基础句柄所在线程上异步执行指定委托。
</code></pre><ol>
<li><p>自我理解</p>
<p> （1）异步的，不一定非得等委托内的代码运行结束才执行</p>
</li>
</ol>
<h1 id="个人实例"><a href="#个人实例" class="headerlink" title="个人实例"></a>个人实例</h1><p><img src="img/invoke.png" alt="图片"></p>
<p>  如图所示，创建一个父窗口，在父窗口中点击按钮弹出一个新的子窗口Form6;</p>
<p>  在子窗口添加按钮点击的时候执行关闭操作（this.Close），同时用根窗口所在的Form弹出另一个Form;</p>
<p>  如果使用Invoke会阻止this.Close的执行；</p>
<p>  如果使用BeginInvoke的话则不会；</p>
<p>##多线程场景</p>
<p>###1：Form关闭的时候回到主线程去弹窗（这有这样才可以）</p>
<pre><code>EventHandler actionDelegate = delegate
   {
       _signInAlertForm.Close();
   };
   mainTreadForm.BeginInvoke(actionDelegate, &quot;&quot;);//主线程对应的Form
</code></pre><p> }</p>
<p>###2：计时器结束的时候想去关掉Form,但是计时器会单独新启动一个线程，此时需要回到创建该控件的线程去执行某个操作(测试这两种都可以)</p>
<pre><code>EventHandler actionDelegate = delegate
     {
         _signInAlertForm.Hide();
     };
     this._signInAlertForm.BeginInvoke(actionDelegate, &quot;&quot;);

      this._signInAlertForm.Invoke(actionDelegate, &quot;&quot;);
 }
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Invoke&quot;&gt;&lt;a href=&quot;#Invoke&quot; class=&quot;headerlink&quot; title=&quot;Invoke&quot;&gt;&lt;/a&gt;Invoke&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;MSDN的解释&lt;/p&gt;
&lt;p&gt; 在拥有此控件的基础窗口句柄的线程上执行指定的委托&lt;/p&gt;

    
    </summary>
    
    
      <category term="c#" scheme="https://wang-yulong.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>c#按F5不能编译的问题以及C#平台和目标平台的区别</title>
    <link href="https://wang-yulong.github.io/2017/05/04/c-%E6%8C%89F5%E4%B8%8D%E8%83%BD%E7%BC%96%E8%AF%91%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://wang-yulong.github.io/2017/05/04/c-按F5不能编译的问题/</id>
    <published>2017-05-04T07:42:40.000Z</published>
    <updated>2017-07-12T16:43:02.946Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-c-按F5不能编译的问题"><a href="#1-c-按F5不能编译的问题" class="headerlink" title="1:c# 按F5不能编译的问题"></a>1:c# 按F5不能编译的问题</h1><p>   在解决方案上右键-》配置管理器：如图</p>
<p><img src="/img/vs1.png" alt="图片1"></p>
<p>  在此处可以配置F5调试运行的时候，是否生成某个项目；</p>
<h1 id="2-平台和目标平台的区别"><a href="#2-平台和目标平台的区别" class="headerlink" title="2:平台和目标平台的区别"></a>2:平台和目标平台的区别</h1><p>  平台（是相对于整个解决方案来说的）</p>
<p>1.整个解决生成的时候默认只生成当前平台下的项目(如图)</p>
<p><img src="/img/vs2.png" alt="图片1"></p>
<p>2.当前也可以在AnyCpu下生成x86的项目（不推荐，编译时会有好多提醒）</p>
<p>3.当前项目-》属性-》生成–》平台–》只有一个可选项时，可以在解决方案右键-》配置管理器（添加新平台）如图</p>
<p><img src="/img/v3.png" alt="图片1"></p>
<p>  目标平台（是指你的程序可以在那个平台上运行）</p>
<p> 1.如果在x86生成(程序可以在32位机以及64位上运行)，之所以这样，是因为windows平台的向下兼容性；</p>
<p> 2.x64(程序可以在32位机和64位机上运行)</p>
<p> 3.anycpu(程序可以在32位机器和64机器上运行)</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-c-按F5不能编译的问题&quot;&gt;&lt;a href=&quot;#1-c-按F5不能编译的问题&quot; class=&quot;headerlink&quot; title=&quot;1:c# 按F5不能编译的问题&quot;&gt;&lt;/a&gt;1:c# 按F5不能编译的问题&lt;/h1&gt;&lt;p&gt;   在解决方案上右键-》配置管理器：如
    
    </summary>
    
    
      <category term="c#" scheme="https://wang-yulong.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>win32 程序开发流程</title>
    <link href="https://wang-yulong.github.io/2017/04/28/win32-%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/"/>
    <id>https://wang-yulong.github.io/2017/04/28/win32-程序开发流程/</id>
    <published>2017-04-28T04:47:34.000Z</published>
    <updated>2017-07-12T16:47:31.283Z</updated>
    
    <content type="html"><![CDATA[<h1 id="win32程序开发流程"><a href="#win32程序开发流程" class="headerlink" title="win32程序开发流程"></a>win32程序开发流程</h1><h2 id="win32特点（message-based–基于消息）-event-driven–事件驱动"><a href="#win32特点（message-based–基于消息）-event-driven–事件驱动" class="headerlink" title="win32特点（message based–基于消息） (event driven–事件驱动)"></a>win32特点（message based–基于消息） (event driven–事件驱动)</h2><p>  win32程序是message based,event driven 。也就是说 win32程序的运行是依靠外部不断发生的事件来驱动的,也就是说，程序不断等待（类似于有一个while循环）,等待任何可能的进入，然后做判断，在做适当的处理。因此win32程序只需要做好如下几件事情就可以了：</p>
<ol>
<li>定义窗口的外观;</li>
<li>定义当不同的事件发生时，程序该做什么样的反应(定义窗口处理函数);</li>
<li>写一个while循环，不断检测新事件的发生，将其发送给不同的窗口处理函数。</li>
</ol>
<h2 id="win32程序入口-WinMain"><a href="#win32程序入口-WinMain" class="headerlink" title="win32程序入口 WinMain"></a>win32程序入口 WinMain</h2><h3 id="main-函数是一般C语言的程序入口"><a href="#main-函数是一般C语言的程序入口" class="headerlink" title="main 函数是一般C语言的程序入口"></a>main 函数是一般C语言的程序入口</h3><pre><code>int main(int args,char *argv[],char *envp[])
</code></pre><h3 id="winMain是win32程序的程序入口"><a href="#winMain是win32程序的程序入口" class="headerlink" title="winMain是win32程序的程序入口"></a>winMain是win32程序的程序入口</h3><pre><code>int CALLBACK WinMain(_in HINSTANCE hInstance,_in HINSTANCE hPrevInstance,
     _in LPSTR lpCmdLine,_in int nCmdShow)
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;win32程序开发流程&quot;&gt;&lt;a href=&quot;#win32程序开发流程&quot; class=&quot;headerlink&quot; title=&quot;win32程序开发流程&quot;&gt;&lt;/a&gt;win32程序开发流程&lt;/h1&gt;&lt;h2 id=&quot;win32特点（message-based–基于消息）-e
    
    </summary>
    
    
      <category term="--win32" scheme="https://wang-yulong.github.io/tags/win32/"/>
    
  </entry>
  
  <entry>
    <title>c#ref与out关键字详解</title>
    <link href="https://wang-yulong.github.io/2017/04/26/c-sharp-ref-%E4%B8%8E-out-%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>https://wang-yulong.github.io/2017/04/26/c-sharp-ref-与-out-关键字/</id>
    <published>2017-04-26T10:48:14.000Z</published>
    <updated>2017-07-12T16:42:27.273Z</updated>
    
    <content type="html"><![CDATA[<h1 id="c-sharp-Ref关键字与out关键字的相同点与不同点"><a href="#c-sharp-Ref关键字与out关键字的相同点与不同点" class="headerlink" title="c#(sharp) Ref关键字与out关键字的相同点与不同点"></a>c#(sharp) Ref关键字与out关键字的相同点与不同点</h1><p>  相同点：方法的定义和调用都必须显示使用ref、out关键字。都会导致参数按引用传递。</p>
<p>  不同点：传递给ref关键字的参数必须赋初始值，而out不用。out关键字会清空变量，即使变量已经赋值也不行，退出函数时所有out引用个变量都要赋值。</p>
<h2 id="Ref关键字（主要用来传值）"><a href="#Ref关键字（主要用来传值）" class="headerlink" title="Ref关键字（主要用来传值）"></a>Ref关键字（主要用来传值）</h2><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><pre><code>  static void Main(String []args)
   {
       int age = 10;
       RefAge(ref age);

       Console.WriteLine(&quot;我现在的年龄是{0}&quot;,age);
       Console.ReadKey();

   }


/// &lt;summary&gt;
  /// 得到当前年龄
  /// &lt;/summary&gt;
  /// &lt;param name=&quot;age&quot;&gt;&lt;/param&gt;
   static void RefAge( ref int age)
  {
      age += 5;
  }
</code></pre><h3 id="运行效果图"><a href="#运行效果图" class="headerlink" title="运行效果图"></a>运行效果图</h3><p><img src="/img/c1.png" alt="图片1"></p>
<h2 id="Out关键字（主要用来取值）解决了函数只能返回一个值的局限性"><a href="#Out关键字（主要用来取值）解决了函数只能返回一个值的局限性" class="headerlink" title="Out关键字（主要用来取值）解决了函数只能返回一个值的局限性"></a>Out关键字（主要用来取值）解决了函数只能返回一个值的局限性</h2><h3 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h3><pre><code>/// &lt;summary&gt;
/// 采用Out关键字根据当前年龄计算上一年的年龄和下一年的年龄
/// &lt;/summary&gt;
/// &lt;param name=&quot;age&quot;&gt;&lt;/param&gt;
/// &lt;param name=&quot;lastYearAge&quot;&gt;&lt;/param&gt;
/// &lt;param name=&quot;nextYearAge&quot;&gt;&lt;/param&gt;
static void OutAge(int age,out int lastYearAge,out int nextYearAge)
{
    lastYearAge = age - 1;
    nextYearAge = age + 1;
}


static void Main(String []args)
{
    int age = 10;
   // RefAge(ref age);

    int lastYearAge;

    int nextYearAge;

    OutAge(age, out lastYearAge,out nextYearAge);

    Console.WriteLine(&quot;我现在的年龄是{0}&quot;,age);
    Console.WriteLine(&quot;我明年的年龄是{0}&quot;, nextYearAge);
    Console.WriteLine(&quot;我去年的年龄是{0}&quot;, lastYearAge);
    Console.ReadKey();
 }
</code></pre><h3 id="运行效果图-1"><a href="#运行效果图-1" class="headerlink" title="运行效果图"></a>运行效果图</h3><p><img src="/img/c2.png" alt="图片2"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;c-sharp-Ref关键字与out关键字的相同点与不同点&quot;&gt;&lt;a href=&quot;#c-sharp-Ref关键字与out关键字的相同点与不同点&quot; class=&quot;headerlink&quot; title=&quot;c#(sharp) Ref关键字与out关键字的相同点与不同点&quot;&gt;&lt;
    
    </summary>
    
    
      <category term="c#" scheme="https://wang-yulong.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>Markdown常见语法</title>
    <link href="https://wang-yulong.github.io/2017/04/15/hexo1/"/>
    <id>https://wang-yulong.github.io/2017/04/15/hexo1/</id>
    <published>2017-04-15T07:28:19.000Z</published>
    <updated>2017-07-12T16:44:04.976Z</updated>
    
    <content type="html"><![CDATA[<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>   hexo 写博客 ，标题title部分必须位于md文件的最上方，否则会报一些莫名其妙的错误。</p>
<h2 id="加粗，斜体"><a href="#加粗，斜体" class="headerlink" title="加粗，斜体"></a>加粗，斜体</h2><p><strong>哈哈哈</strong>(“<strong>哈哈哈</strong>“)</p>
<p><em>12342343</em></p>
<h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><ol>
<li>列表项1</li>
<li>列表2</li>
<li>列表3</li>
</ol>
<h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><ul>
<li>无序1</li>
<li>无序2</li>
<li>无序3</li>
</ul>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><blockquote>
<p>这个是一个引用</p>
</blockquote>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><h3 id="普通链接"><a href="#普通链接" class="headerlink" title="普通链接"></a>普通链接</h3><p><a href="www.baidu.com" title="123">链接测试</a></p>
<h3 id="行内链接"><a href="#行内链接" class="headerlink" title="行内链接"></a>行内链接</h3><p>This is <a href="http://example.com/" title="Title" target="_blank" rel="external">an example</a> inline link.</p>
<p><a href="http://example.net/" target="_blank" rel="external">This link</a> has no title attribute.</p>
<h3 id="参考式"><a href="#参考式" class="headerlink" title="参考式"></a>参考式</h3><p>我经常去的几个网站<a href="http://www.baidu.com" title="Baidu" target="_blank" rel="external">百度</a>、<a href="http://www.leanote.com" title="Leanote" target="_blank" rel="external">Leanote</a>以及<a href="http://http://blog.leanote.com/freewalk" title="梵居闹市" target="_blank" rel="external">自己的博客</a><br><a href="http://www.leanote.com" title="Leanote" target="_blank" rel="external">Leanote 笔记</a>是一个不错的<a href="http://http://blog.leanote.com/freewalk" target="_blank" rel="external">网站</a>。</p>
<h3 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径"></a>相对路径</h3><p>See my <a href="/about/">About</a> page for details</p>
<h3 id="自动链接"><a href="#自动链接" class="headerlink" title="自动链接"></a>自动链接</h3><p><a href="http://example.com/" target="_blank" rel="external">http://example.com/</a></p>
<p><a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#x6f;&#x3a;&#x61;&#100;&#100;&#114;&#x65;&#115;&#115;&#x40;&#49;&#x34;&#50;&#x35;&#50;&#50;&#54;&#x34;&#x36;&#54;&#x40;&#113;&#x71;&#x2e;&#x63;&#x6f;&#109;">&#x61;&#100;&#100;&#114;&#x65;&#115;&#115;&#x40;&#49;&#x34;&#50;&#x35;&#50;&#50;&#54;&#x34;&#x36;&#54;&#x40;&#113;&#x71;&#x2e;&#x63;&#x6f;&#109;</a></p>
<h2 id="锚点-没实现"><a href="#锚点-没实现" class="headerlink" title="锚点(没实现)"></a>锚点(没实现)</h2><p>跳转到<a href="#index">注意事项</a></p>
<p>Markdown<br>:    轻量级文本标记语言，可以转换成html，pdf等格式（左侧有一个可见的冒号和四个不可见的空格）<br>代码块 2<br>:   这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格）<br>        代码块（左侧有八个不可见的空格）</p>
<ul>
<li><p>阅读的方法:</p>
<blockquote>
<p>打开书本。<br>打开电灯。</p>
</blockquote>
</li>
<li><p>&lt;代码写在这&gt;</p>
</li>
</ul>
<h2 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h2><p>##32343</p>
<h2 id="注脚"><a href="#注脚" class="headerlink" title="注脚"></a>注脚</h2><p>使用 Markdown<a href="Markdown是一种纯文本标记语言">^1</a>可以效率的书写文档, 直接转换成 HTML[^2] , 你可以使用 Leanote<a href="开源笔记平台，支持Markdown和笔记直接发为博文">^Le</a> 编辑器进行书写。</p>
<p>[^2]:HyperText Markup Language 超文本标记语言</p>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><h3 id="网页版"><a href="#网页版" class="headerlink" title="网页版"></a>网页版</h3><p><img src="http://preview.quanjing.com/ph070/ph4260-p00756.jpg" alt="图片"></p>
<h3 id="本地图片"><a href="#本地图片" class="headerlink" title="本地图片"></a>本地图片</h3><p><img src="/img/2.jpg" alt="图片"></p>
<h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><hr>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><table>
<thead>
<tr>
<th>Tables</th>
<th style="text-align:center">Are</th>
<th style="text-align:right">Cool</th>
</tr>
</thead>
<tbody>
<tr>
<td>col 3 is</td>
<td style="text-align:center">right-aligned</td>
<td style="text-align:right">$1600</td>
</tr>
<tr>
<td>col 2 is</td>
<td style="text-align:center">centered</td>
<td style="text-align:right">$12</td>
</tr>
<tr>
<td>zebra stripes</td>
<td style="text-align:center">are neat</td>
<td style="text-align:right">$1</td>
</tr>
</tbody>
</table>
<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><h3 id="单行代码"><a href="#单行代码" class="headerlink" title="单行代码"></a>单行代码</h3><p>  <code>MessageBox.Show(&quot;单行代码&quot;);</code></p>
<h3 id="单行（行内式）代码"><a href="#单行（行内式）代码" class="headerlink" title="单行（行内式）代码"></a>单行（行内式）代码</h3><p>C语言里的函数 <code>scanf()</code> 怎么使用？</p>
<h3 id="缩进式"><a href="#缩进式" class="headerlink" title="缩进式"></a>缩进式</h3><pre><code>缩进 4 个空格或是 1 个制表符

一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。

#include &lt;stdio.h&gt;
int main(void)
{
    printf(&quot;Hello world\n&quot;);
}
</code></pre><h3 id="多行代码"><a href="#多行代码" class="headerlink" title="多行代码"></a>多行代码</h3><pre><code><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Hello world\n"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><hr>
<h2 id="html-代码可以直接解析"><a href="#html-代码可以直接解析" class="headerlink" title="html 代码可以直接解析"></a>html 代码可以直接解析</h2><table><br>    <tr><br>        <th rowspan="2">值班人员</th><br>        <th>星期一</th><br>        <th>星期二</th><br>        <th>星期三</th><br>    </tr><br>    <tr><br>        <td>李强</td><br>        <td>张明</td><br>        <td>王平</td><br>    </tr><br></table>

<p><br></p>
<p><br></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;注意事项&quot;&gt;&lt;a href=&quot;#注意事项&quot; class=&quot;headerlink&quot; title=&quot;注意事项&quot;&gt;&lt;/a&gt;注意事项&lt;/h2&gt;&lt;p&gt;   hexo 写博客 ，标题title部分必须位于md文件的最上方，否则会报一些莫名其妙的错误。&lt;/p&gt;
&lt;h2 id=&quot;
    
    </summary>
    
    
      <category term="工具类" scheme="https://wang-yulong.github.io/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
  </entry>
  
</feed>
