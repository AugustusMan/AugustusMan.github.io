{"meta":{"title":"一人静在书中","subtitle":"记录学习的技能和遇到的问题","description":"莫等闲,白了少年头！","author":"王玉龙","url":"https://wang-yulong.github.io"},"pages":[{"title":"about","date":"2017-04-15T00:23:56.000Z","updated":"2017-04-15T00:23:56.097Z","comments":true,"path":"about/index.html","permalink":"https://wang-yulong.github.io/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-06-25T01:13:39.000Z","updated":"2017-06-25T01:14:51.224Z","comments":true,"path":"tags/index.html","permalink":"https://wang-yulong.github.io/tags/index.html","excerpt":"","text":""},{"title":"win32 程序开发流程","date":"2017-04-28T04:46:09.000Z","updated":"2017-04-28T04:46:09.364Z","comments":true,"path":"win32-程序开发流程/index.html","permalink":"https://wang-yulong.github.io/win32-程序开发流程/index.html","excerpt":"","text":""},{"title":"categories","date":"2017-06-25T01:10:50.000Z","updated":"2017-06-25T01:12:28.517Z","comments":true,"path":"categories/index.html","permalink":"https://wang-yulong.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"struts2重定向传输汉字的问题","slug":"struts2重定向传输汉字的问题","date":"2017-07-06T11:42:37.000Z","updated":"2017-07-06T12:15:43.776Z","comments":true,"path":"2017/07/06/struts2重定向传输汉字的问题/","link":"","permalink":"https://wang-yulong.github.io/2017/07/06/struts2重定向传输汉字的问题/","excerpt":"","text":"##struts中的配置 1) &lt;package name=&quot;test1&quot; namespace=&quot;&quot; extends=&quot;struts-default&quot;&gt; &lt;action name=&quot;test1Action&quot; class=&quot;com.action.UserAction&quot; method=&quot;testAction&quot;&gt; &lt;result name=&quot;success&quot; type=&quot;redirect&quot; &gt; &lt;param name=&quot;location&quot;&gt;/showMsg.jsp?message=${message}&lt;/param&gt; &lt;param name=&quot;encode&quot;&gt;true&lt;/param&gt; &lt;/result&gt; &lt;/action&gt; &lt;/package&gt; 2） &lt;package name=&quot;test1&quot; namespace=&quot;&quot; extends=&quot;struts-default&quot;&gt; &lt;action name=&quot;test1Action&quot; class=&quot;com.action.UserAction&quot; method=&quot;testAction&quot;&gt; &lt;result name=&quot;success&quot; type=&quot;redirect&quot;&gt;/login.jsp?message=${message}&lt;/result&gt; &lt;/action&gt; &lt;/package&gt; 两种都可以 ##方案1 修改tomcat安装目录下的config目录下server.xml 针对8080和8089都增加参数 URIEncoding=&quot;UTF-8&quot; action中 public String testAction() throws UnsupportedEncodingException { setMessage(&quot;el 表达式中文测试 test&quot;); return &quot;success&quot;; } ...get/set方法 message ##方案2 在action中对汉字进行编码，在jsp页面中进行解码，具体如下 1）action中 private String message; public String testAction() throws UnsupportedEncodingException { setMessage(URLEncoder.encode(&quot;el 表达式中文测试 test&quot;,&quot;UTF-8&quot;)); return &quot;success&quot;; } ...get/set方法 message 2）jsp中 &lt;% String userName= request.getParameter(&quot;message&quot;); userName=new String(userName.getBytes(&quot;iso8859-1&quot;),&quot;UTF-8&quot;); // userName=URLDecoder.decode(userName,&quot;UTF-8&quot;); 实测不加也可以 out.println(message); %&gt; 感觉方案1比较好，但是如果不方便修改服务器配置的话，第二种也可以，就是代码有点累赘 ##扩展（tomcat的端口的简单描述） 8080：http端口 8443：https端口 8005：远程停服务器端口 &lt;Server port=&quot;8005&quot; shutdown=&quot;SHUTDOWN&quot;&gt; 8009：AJP端口 AJP（Apache JServ Protocol）是定向包协议。因为性能原因，使用二进制格式来传输可读性文本。WEB服务器通过 TCP连接 和 SERVLET容器连接。","categories":[],"tags":[{"name":"-struts2","slug":"struts2","permalink":"https://wang-yulong.github.io/tags/struts2/"}]},{"title":"'mysql建表不能用作变量名称的'","slug":"mysql建表不能用作变量名称的","date":"2017-06-30T04:33:04.000Z","updated":"2017-06-30T04:35:38.607Z","comments":true,"path":"2017/06/30/mysql建表不能用作变量名称的/","link":"","permalink":"https://wang-yulong.github.io/2017/06/30/mysql建表不能用作变量名称的/","excerpt":"","text":"##mysql 建表的时候这些词不能当做列名，否则批接sql串查询的时候会有一些莫名其妙的问题，此处只是用于记录； ###1 index ###2 key","categories":[],"tags":[]},{"title":"'mysql用法总结'","slug":"mysql用法总结","date":"2017-06-27T08:24:40.000Z","updated":"2017-06-27T09:08:37.307Z","comments":true,"path":"2017/06/27/mysql用法总结/","link":"","permalink":"https://wang-yulong.github.io/2017/06/27/mysql用法总结/","excerpt":"","text":"##1:mysql建表，带时间戳 DROP TABLE IF EXISTS CONTENT; CREATE TABLE CONTENT ( ID char(20) NOT NULL, CURRENT_TIME timestamp not null default current_timestamp, PRIMARY KEY (ID) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; 存储引擎是innodb。nnoDB 是 MySQL 上第一个提供外键约束的数据存储引擎，除了提供事务处理外，InnoDB 还支持行锁，提供和 Oracle 一样的一致性的不加锁读取，能增加并发读的用户数量并提高性能，不会增加锁的数量。InnoDB 的设计目标是处理大容量数据时最大化性能，它的 CPU 利用率是其他所有基于磁盘的关系数据库引擎中最有效率的。 InnoDB 是一套放在 MySQL 后台的完整数据库系统，InnoDB 有它自己的缓冲池，能缓冲数据和索引，InnoDB 还把数据和索引存放在表空间里面，可能包含好几个文件，这和 MyISAM 表完全不同，在 MyISAM 中，表被存放在单独的文件中，InnoDB 表的大小只受限于操作系统文件的大小，一般为 2GB。 ##2: mysql导出建表语句 数据库-&gt;右键-&gt;转储为SQL","categories":[],"tags":[{"name":"-mysql","slug":"mysql","permalink":"https://wang-yulong.github.io/tags/mysql/"}]},{"title":"'html常见问题'","slug":"html常见问题","date":"2017-06-27T07:12:26.000Z","updated":"2017-06-29T06:36:28.787Z","comments":true,"path":"2017/06/27/html常见问题/","link":"","permalink":"https://wang-yulong.github.io/2017/06/27/html常见问题/","excerpt":"","text":"##1 :$.ajax返回一个对象 客户端： $.ajax({ type:&quot;Get&quot;, url:&quot;CommonServlet&quot;, data: { functionName:&quot;&lt;%=RequestConst.QuerySingleTemplate %&gt;&quot;, templateId:$(&quot;#sel&quot;).val(), }, dataType:&quot;json&quot;, success:function(obj) { //var template=eval(obj); //alert(&quot;12423&quot;); alert(obj.url); //$(&quot;#templateUrl&quot;).val(template.url); } }); 服务端: response.getWriter().print(JSONObject.fromObject(templateInfo)); ##2 eval(“3*10”)执行表达式的内容","categories":[],"tags":[{"name":"html","slug":"html","permalink":"https://wang-yulong.github.io/tags/html/"}]},{"title":"'jsp乱码总结'","slug":"jsp乱码总结","date":"2017-06-27T06:53:46.000Z","updated":"2017-06-27T07:12:53.142Z","comments":true,"path":"2017/06/27/jsp乱码总结/","link":"","permalink":"https://wang-yulong.github.io/2017/06/27/jsp乱码总结/","excerpt":"","text":"##java web项目乱码的常用解决方法 request.setCharetEncoding(“utf-8”); response.setCharerEncoding(“utf-8”); response.setContextType(“text/html;charset=utf-8”); 如果是request.getParameter(“参数名称”)获取中文乱码 String keyCodeStr=request.getParameter(&quot;keyCodeStr&quot;); keyCodeStr= new String(keyCodeStr.getBytes(&quot;ISO8851-1&quot;),&quot;utf-8&quot;);","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://wang-yulong.github.io/tags/java/"}]},{"title":"rss报错原因记录","slug":"rss报错原因记录","date":"2017-06-25T03:25:05.000Z","updated":"2017-06-25T03:30:40.220Z","comments":true,"path":"2017/06/25/rss报错原因记录/","link":"","permalink":"https://wang-yulong.github.io/2017/06/25/rss报错原因记录/","excerpt":"","text":"打开Rss报错如图 Input is not proper UTF-8, indicate encoding 原因可能如下： 使用了特殊字串”:”(冒号中文的) 使用了#号 参考： http://blog.csdn.net/isaisai/article/details/53899089","categories":[],"tags":[]},{"title":"myeclipse常用快捷键","slug":"myeclipse常用快捷键","date":"2017-06-22T08:41:38.000Z","updated":"2017-06-22T10:04:36.540Z","comments":true,"path":"2017/06/22/myeclipse常用快捷键/","link":"","permalink":"https://wang-yulong.github.io/2017/06/22/myeclipse常用快捷键/","excerpt":"","text":"##Myeclipse常用快捷键标记 1：Ctrl+H 搜索整个项目 2：Ctrl+Shift+O 导包 3：Alt+Shift+S 快捷实现接口，get/set方法，构造函数等 4：Alt+Shift+J 快速注释（需要选中函数或者属性名称） 5:Alt+← 或者 Alt+→ 到上一步或者下一步位置 6 显示行号 windows-&gt;preferences-&gt;general-&gt;editors-&gt;Text Editer-&gt;show line numbers","categories":[],"tags":[]},{"title":"mysql绿色版安装步骤","slug":"mysql安装","date":"2017-06-21T12:11:52.000Z","updated":"2017-06-25T03:11:41.685Z","comments":true,"path":"2017/06/21/mysql安装/","link":"","permalink":"https://wang-yulong.github.io/2017/06/21/mysql安装/","excerpt":"","text":"##1:在官网下载https://dev.mysql.com/downloads/mysql/（如图） ##2:解压之后，首先在解决的当前目录下添加my.ini文件(内容如下) [client] port=3306 default-character-set=utf8 [mysqld] # 设置为MYSQL的安装目录 basedir=E:\\mysql-5.7.18-winx64 # 设置为MYSQL的数据目录 datadir=E:\\mysql-5.7.18-winx64\\data port=3306 character_set_server=utf8 sql_mode=NO_ENGINE_SUBSTITUTION,NO_AUTO_CREATE_USER #开启查询缓存 explicit_defaults_for_timestamp=true 3:(cd 切到解压目录/bin)依次执行如下命令mysqld -install（注册mysql服务 mysqld --initilize --user=mysql --datadir=data(初始化mysql的data,密码等信息 初始化root的密码为空) net start mysql(启动mysql服务) net start mysql mysqladmin -u root -p password(设置新密码) ##4:常见问题 (1) mysqld -install 结果Install/Remove of the Service Denied! 解决方案：进入 C:\\Window\\System32 找到CMD.EXE 右键选择 以管理员身份 进行，再进入相应目录执行命令，一切就OK了。 (2)执行报错 应用程序无法正常启动（0x000007b） 如图 解决方案：可以使用如何使用DirectX修复工具进行修复 详细可查看 http://jingyan.baidu.com/article/ed2a5d1f57a1ab09f6be17d8.html (3) 部署java web项目到服务器，老是提示“java.sql.SQLException: No suitable driver found for jdbc:mysql” 1.查了好久发现是,java web项目虽然成功部署了，但是mysql-connector-java-3.1.14-bin.jar并没有复制到 “webapps\\WeixinCoreServlet\\WEB-INF\\lib ”该目录下，导包的方式是bulid_path那样导的，虽然导入成功了， 但是并不复制，必须手动刷新（右键项目-&gt;刷新(F5)）myelipse 2014下发生的 （4）执行查询报错 Host &apos;XXX&apos; is not allowed to connect to this MySQL server 原因：未授权远程账号 解决方案： 1.在 Windows 主机中点击开始菜单，运行，输入“cmd”，进入控制台，然后cd 进入MySQL 的 bin 目录下，然后输入下面的命令。 mysql -uroot -p123456 (123456 为 root 用户的密码。) 2.创建远程登陆用户并授权 grant all PRIVILEGES on test_db.* to root@&apos;192.168.1.101&apos; identified by &apos;123456&apos;; 引用：http://www.cnblogs.com/zhangzhu/archive/2013/08/22/3274831.html (5)mysql 运行时报错（如下） Establishing SSL connection without server&apos;s identity verification is not recommended. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification. 原因分析：mysql高版本需要指明是否安全连接 解决方案：（mysql的连接串改为如下配置） “ jbbcLmysql://localhost:3306/weixin?characterEncoding=utf8&amp;useSSL=true ”","categories":[{"name":"MySql","slug":"MySql","permalink":"https://wang-yulong.github.io/categories/MySql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://wang-yulong.github.io/tags/mysql/"}]},{"title":"'JavaWeb(开发微信公众账号)微信开发遇到的问题'","slug":"微信开发遇到的问题","date":"2017-06-20T12:22:54.000Z","updated":"2017-06-20T12:57:51.306Z","comments":true,"path":"2017/06/20/微信开发遇到的问题/","link":"","permalink":"https://wang-yulong.github.io/2017/06/20/微信开发遇到的问题/","excerpt":"","text":"1：回复消息老是提示”该公众号暂时无法提供服务，请稍后再试”查了好久，发现并不是网上说的返回值为空的为题，而是web.xml中 servelt的映射路径写错了。。如图所示 2: 本地调试环境的配置1：下载ngrok （https://dashboard.ngrok.com） 2: 注册获取 （authtoken) 3: 运行ngrok.exe 4: 执行 ngrok authtoken 5x5JMF92LuLTfXaT8YA7N_6mMqPvzAKyircey21JHW2(注册生成的authtoken) 5: 执行 ngrok http 8080 如图 可生成如此结果 此时在微信公众平台进行填入上面红色框内的内容，进行重新映射","categories":[],"tags":[]},{"title":"C#_封装之（List与Dictionary）","slug":"C-sharp封装（List与Dictionary）","date":"2017-06-09T12:30:43.000Z","updated":"2017-06-25T03:18:59.562Z","comments":true,"path":"2017/06/09/C-sharp封装（List与Dictionary）/","link":"","permalink":"https://wang-yulong.github.io/2017/06/09/C-sharp封装（List与Dictionary）/","excerpt":"","text":"##简单描述 KeyedList: 同时实现IDictionary和IList接口的集合。 带有索引的List使用上会比较方便，可以通过Key来索引Value。 同时内部是线性存储的，可以保证顺序，可以使用下标访问数据。 内部使用Dictionary来存储Key到Value的映射， List存储KeyValuePair。有很大的冗余，可以参考（小规模的数据用着还是比较方便的） 代码: [Serializable] [Obsolete(&quot;未完善，有冗余&quot;)] public sealed class KeyedList&lt;TKey, TValue&gt; : IDictionary&lt;TKey, TValue&gt;, IList&lt;KeyValuePair&lt;TKey, TValue&gt;&gt; { private readonly Dictionary&lt;TKey, TValue&gt; _dict = new Dictionary&lt;TKey, TValue&gt;(); private readonly List&lt;KeyValuePair&lt;TKey, TValue&gt;&gt; _list = new List&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;(); /// &lt;summary&gt; /// Returns false. /// &lt;/summary&gt; public bool IsReadOnly { get { return false; } } /// &lt;summary&gt; /// Returns the number of entries in the KeyedList. /// &lt;/summary&gt; public int Count { get { return _list.Count; } } /// &lt;summary&gt; /// Get/Set the value at the specified index. /// &lt;/summary&gt; /// &lt;param name=&quot;index&quot;&gt;The index.&lt;/param&gt; /// &lt;returns&gt;The value.&lt;/returns&gt; public KeyValuePair&lt;TKey, TValue&gt; this[int index] { get { if (index &lt; 0 || index &gt;= Count) { throw new ArgumentOutOfRangeException(&quot;index&quot;); } return _list[index]; } set { if (index &lt; 0 || index &gt;= Count) { throw new ArgumentOutOfRangeException(&quot;index&quot;); } _list[index] = value; _dict[value.Key] = value.Value; } } /// &lt;summary&gt; /// Get/Set the value associated with the specified key. /// &lt;/summary&gt; /// &lt;param name=&quot;key&quot;&gt;The key.&lt;/param&gt; /// &lt;returns&gt;The associated value.&lt;/returns&gt; public TValue this[TKey key] { get { return _dict[key]; } set { if (_dict.ContainsKey(key)) { _dict[key] = value; _list[IndexOf(key)] = new KeyValuePair&lt;TKey, TValue&gt;(key, value); } else { Add(key, value); } } } /// &lt;summary&gt; /// Get an unordered list of keys. /// This collection refers back to the keys in the original Dictionary. /// &lt;/summary&gt; public ICollection&lt;TKey&gt; Keys { get { return _dict.Keys; } } /// &lt;summary&gt; /// Get an unordered list of values. /// This collection refers back to the values in the original Dictionary. /// &lt;/summary&gt; public ICollection&lt;TValue&gt; Values { get { return _dict.Values; } } /// &lt;summary&gt; /// Get the ordered list of keys. /// This is a copy of the keys in the original Dictionary. /// &lt;/summary&gt; public List&lt;TKey&gt; OrderedKeys { get { List&lt;TKey&gt; retList = new List&lt;TKey&gt;(); foreach (KeyValuePair&lt;TKey, TValue&gt; kvp in _list) { retList.Add(kvp.Key); } return retList; } } /// &lt;summary&gt; /// Get the ordered list of values. /// This is a copy of the values in the original Dictionary. /// &lt;/summary&gt; public List&lt;TValue&gt; OrderedValues { get { List&lt;TValue&gt; retList = new List&lt;TValue&gt;(); foreach (KeyValuePair&lt;TKey, TValue&gt; kvp in _list) { retList.Add(kvp.Value); } return retList; } } /// &lt;summary&gt; /// Returns the key at the specified index. /// &lt;/summary&gt; /// &lt;param name=&quot;idx&quot;&gt;The index.&lt;/param&gt; /// &lt;returns&gt;The key at the index.&lt;/returns&gt; public TKey GetKey(int idx) { if (idx &lt; 0 || idx &gt;= Count) { throw new ArgumentOutOfRangeException(&quot;index&quot;); } return _list[idx].Key; } /// &lt;summary&gt; /// Returns the value at the specified index. /// &lt;/summary&gt; /// &lt;param name=&quot;idx&quot;&gt;The index.&lt;/param&gt; /// &lt;returns&gt;The value at the index.&lt;/returns&gt; public TValue GetValue(int idx) { if (idx &lt; 0 || idx &gt;= Count) { throw new ArgumentOutOfRangeException(&quot;index&quot;); } return _list[idx].Value; } /// &lt;summary&gt; /// Get the index of a particular key. /// &lt;/summary&gt; /// &lt;param name=&quot;key&quot;&gt;The key to find the index of.&lt;/param&gt; /// &lt;returns&gt;The index of the key, or -1 if not found.&lt;/returns&gt; public int IndexOf(TKey key) { int ret = -1; for (int i = 0; i &lt; _list.Count; i++) { if (_list[i].Key.Equals(key)) { ret = i; break; } } return ret; } /// &lt;summary&gt; /// Given the key-value pair, find the index. /// &lt;/summary&gt; /// &lt;param name=&quot;kvp&quot;&gt;The key-value pair.&lt;/param&gt; /// &lt;returns&gt;The index, or -1 if not found.&lt;/returns&gt; public int IndexOf(KeyValuePair&lt;TKey, TValue&gt; kvp) { return IndexOf(kvp.Key); } /// &lt;summary&gt; /// Gets the Dictionary class backing the KeyedList. /// &lt;/summary&gt; public Dictionary&lt;TKey, TValue&gt; ObjectTable { get { return _dict; } } /// &lt;summary&gt; /// Clears all entries in the KeyedList. /// &lt;/summary&gt; public void Clear() { _dict.Clear(); _list.Clear(); } /// &lt;summary&gt; /// Test if the KeyedList contains the key. /// &lt;/summary&gt; /// &lt;param name=&quot;key&quot;&gt;The key.&lt;/param&gt; /// &lt;returns&gt;True if the key is found.&lt;/returns&gt; public bool ContainsKey(TKey key) { return _dict.ContainsKey(key); } /// &lt;summary&gt; /// Test if the KeyedList contains the key in the key-value pair. /// &lt;/summary&gt; /// &lt;param name=&quot;kvp&quot;&gt;The key-value pair.&lt;/param&gt; /// &lt;returns&gt;True if the key is found.&lt;/returns&gt; public bool Contains(KeyValuePair&lt;TKey, TValue&gt; kvp) { return _dict.ContainsKey(kvp.Key); } /// &lt;summary&gt; /// Adds a key-value pair to the KeyedList. /// &lt;/summary&gt; /// &lt;param name=&quot;key&quot;&gt;The key.&lt;/param&gt; /// &lt;param name=&quot;value&quot;&gt;The associated value.&lt;/param&gt; public void Add(TKey key, TValue value) { _dict.Add(key, value); _list.Add(new KeyValuePair&lt;TKey, TValue&gt;(key, value)); } /// &lt;summary&gt; /// Adds a key-value pair to the KeyedList. /// &lt;/summary&gt; /// &lt;param name=&quot;kvp&quot;&gt;The KeyValuePair instance.&lt;/param&gt; public void Add(KeyValuePair&lt;TKey, TValue&gt; kvp) { Add(kvp.Key, kvp.Value); } /// &lt;summary&gt; /// Copy the entire key-value pairs to the KeyValuePair array, starting /// at the specified index of the target array. The array is populated /// as an ordered list. /// &lt;/summary&gt; /// &lt;param name=&quot;kvpa&quot;&gt;The KeyValuePair array.&lt;/param&gt; /// &lt;param name=&quot;idx&quot;&gt;The position to start the copy.&lt;/param&gt; public void CopyTo(KeyValuePair&lt;TKey, TValue&gt;[] kvpa, int idx) { _list.CopyTo(kvpa, idx); } /// &lt;summary&gt; /// Insert the key-value at the specified index. /// &lt;/summary&gt; /// &lt;param name=&quot;idx&quot;&gt;The zero-based insert point.&lt;/param&gt; /// &lt;param name=&quot;key&quot;&gt;The key.&lt;/param&gt; /// &lt;param name=&quot;value&quot;&gt;The value.&lt;/param&gt; public void Insert(int idx, TKey key, TValue value) { if ((idx &lt; 0) || (idx &gt; Count)) { throw new ArgumentOutOfRangeException(&quot;index&quot;); } _dict.Add(key, value); _list.Insert(idx, new KeyValuePair&lt;TKey, TValue&gt;(key, value)); } /// &lt;summary&gt; /// Insert the key-value pair at the specified index location. /// &lt;/summary&gt; /// &lt;param name=&quot;idx&quot;&gt;The key.&lt;/param&gt; /// &lt;param name=&quot;kvp&quot;&gt;The value.&lt;/param&gt; public void Insert(int idx, KeyValuePair&lt;TKey, TValue&gt; kvp) { if ((idx &lt; 0) || (idx &gt; Count)) { throw new ArgumentOutOfRangeException(&quot;index&quot;); } _dict.Add(kvp.Key, kvp.Value); _list.Insert(idx, kvp); } /// &lt;summary&gt; /// Remove the entry. /// &lt;/summary&gt; /// &lt;param name=&quot;key&quot;&gt;The key identifying the key-value pair.&lt;/param&gt; /// &lt;returns&gt;True if removed.&lt;/returns&gt; public bool Remove(TKey key) { bool found = _dict.Remove(key); if (found) { _list.RemoveAt(IndexOf(key)); } return found; } /// &lt;summary&gt; /// Remove the key in the specified KeyValuePair instance. The Value /// property is ignored. /// &lt;/summary&gt; /// &lt;param name=&quot;kvp&quot;&gt;The key-value identifying the entry.&lt;/param&gt; /// &lt;returns&gt;True if removed.&lt;/returns&gt; public bool Remove(KeyValuePair&lt;TKey, TValue&gt; kvp) { return Remove(kvp.Key); } /// &lt;summary&gt; /// Remove the entry at the specified index. /// &lt;/summary&gt; /// &lt;param name=&quot;idx&quot;&gt;The index to the entry to be removed.&lt;/param&gt; public void RemoveAt(int idx) { if ((idx &lt; 0) || (idx &gt;= Count)) { throw new ArgumentOutOfRangeException(&quot;index&quot;); } _dict.Remove(_list[idx].Key); _list.RemoveAt(idx); } /// &lt;summary&gt; /// Attempt to get the value, given the key, without throwing an exception if not found. /// &lt;/summary&gt; /// &lt;param name=&quot;key&quot;&gt;The key indentifying the entry.&lt;/param&gt; /// &lt;param name=&quot;val&quot;&gt;The value, if found.&lt;/param&gt; /// &lt;returns&gt;True if found.&lt;/returns&gt; public bool TryGetValue(TKey key, out TValue val) { return _dict.TryGetValue(key, out val); } /// &lt;summary&gt; /// Returns an ordered System.Collections KeyValuePair objects. /// &lt;/summary&gt; IEnumerator IEnumerable.GetEnumerator() { return _list.GetEnumerator(); } /// &lt;summary&gt; /// Returns an ordered KeyValuePair enumerator. /// &lt;/summary&gt; IEnumerator&lt;KeyValuePair&lt;TKey, TValue&gt;&gt; IEnumerable&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;.GetEnumerator() { return _list.GetEnumerator(); } }","categories":[],"tags":[]},{"title":"c# GDI测量某个点在某个不规则路径上或路径中","slug":"c-测量类","date":"2017-05-23T07:07:36.000Z","updated":"2017-05-23T07:35:38.225Z","comments":true,"path":"2017/05/23/c-测量类/","link":"","permalink":"https://wang-yulong.github.io/2017/05/23/c-测量类/","excerpt":"","text":"#测量某个点是否在不规则路径上 1：对路径进行克隆（防止当前的操作影响所要渲染的路径）bool isExist=false; var path = (GraphicsPath)_path.Clone(); 2： 创建Matrix对象（3*3的矩阵），用来对该路径进行平移（TransLate），缩放（Scale），旋转（Rotate） Matrix matrix = new Matrix(); matrix.Translate(this.Location.X, this.Location.Y); path.Transform(matrix); 3:用画笔为路径增加轮廓（因为GraphicsPath本来起始是没有空间，也就无从谈起是否落在该路径上）using (var pen = new Pen(Color.FromArgb(0, 153, 229), 6)) { path.Widen(pen); } 4：判断改点是否在路径上if (path.IsVisible(pt)) { isExist = true; } 通过以上4步便可以知道某个点是不是在不规则路径上 测量某个点是否在不规则路径中## GraphicsPath path = new GraphicsPath(); // 指示由矩形和由路径构成的图形形状的内部。无法继承此类。 Region myRegion = new Region(); myGraphicsPath.Reset(); Point inputpoint1 = new Point(inputx1, inputy1); Point inputpoint2 = new Point(inputx2, inputy2); myGraphicsPath.AddPolygon(inputpoint1); myGraphicsPath.AddPolygon(inputpoint2); myRegion.MakeEmpty(); myRegion.Union(myGraphicsPath); //返回判断点是否在不规则路径中 bool result= myRegion.IsVisible(inputponint);","categories":[],"tags":[]},{"title":"c# invoke和BeginInvoke 细节收录","slug":"c-invoke和BeginInvoke-细节收录","date":"2017-05-05T12:34:08.000Z","updated":"2017-05-24T12:53:21.713Z","comments":true,"path":"2017/05/05/c-invoke和BeginInvoke-细节收录/","link":"","permalink":"https://wang-yulong.github.io/2017/05/05/c-invoke和BeginInvoke-细节收录/","excerpt":"","text":"Invoke MSDN的解释 在拥有此控件的基础窗口句柄的线程上执行指定的委托 自我理解 （1）同步的，必须得等委托内的代码执行完成之后才能执行 BeginInvoke MSDN的解释 在创建控件的基础句柄所在线程上异步执行指定委托。 自我理解 （1）异步的，不一定非得等委托内的代码运行结束才执行 个人实例 如图所示，创建一个父窗口，在父窗口中点击按钮弹出一个新的子窗口Form6; 在子窗口添加按钮点击的时候执行关闭操作（this.Close），同时用根窗口所在的Form弹出另一个Form; 如果使用Invoke会阻止this.Close的执行； 如果使用BeginInvoke的话则不会； ##多线程场景 ###1：Form关闭的时候回到主线程去弹窗（这有这样才可以） EventHandler actionDelegate = delegate { _signInAlertForm.Close(); }; mainTreadForm.BeginInvoke(actionDelegate, &quot;&quot;);//主线程对应的Form } ###2：计时器结束的时候想去关掉Form,但是计时器会单独新启动一个线程，此时需要回到创建该控件的线程去执行某个操作(测试这两种都可以) EventHandler actionDelegate = delegate { _signInAlertForm.Hide(); }; this._signInAlertForm.BeginInvoke(actionDelegate, &quot;&quot;); this._signInAlertForm.Invoke(actionDelegate, &quot;&quot;); }","categories":[],"tags":[]},{"title":"c#按F5不能编译的问题以及C#平台和目标平台的区别","slug":"c-按F5不能编译的问题","date":"2017-05-04T07:42:40.000Z","updated":"2017-05-04T08:06:31.491Z","comments":true,"path":"2017/05/04/c-按F5不能编译的问题/","link":"","permalink":"https://wang-yulong.github.io/2017/05/04/c-按F5不能编译的问题/","excerpt":"","text":"1:c# 按F5不能编译的问题 在解决方案上右键-》配置管理器：如图 在此处可以配置F5调试运行的时候，是否生成某个项目； 2:平台和目标平台的区别 平台（是相对于整个解决方案来说的） 1.整个解决生成的时候默认只生成当前平台下的项目(如图) 2.当前也可以在AnyCpu下生成x86的项目（不推荐，编译时会有好多提醒） 3.当前项目-》属性-》生成–》平台–》只有一个可选项时，可以在解决方案右键-》配置管理器（添加新平台）如图 目标平台（是指你的程序可以在那个平台上运行） 1.如果在x86生成(程序可以在32位机以及64位上运行)，之所以这样，是因为windows平台的向下兼容性； 2.x64(程序可以在32位机和64位机上运行) 3.anycpu(程序可以在32位机器和64机器上运行)","categories":[],"tags":[]},{"title":"win32 程序开发流程","slug":"win32-程序开发流程","date":"2017-04-28T04:47:34.000Z","updated":"2017-04-28T05:25:34.518Z","comments":true,"path":"2017/04/28/win32-程序开发流程/","link":"","permalink":"https://wang-yulong.github.io/2017/04/28/win32-程序开发流程/","excerpt":"","text":"win32程序开发流程win32特点（message based–基于消息） (event driven–事件驱动) win32程序是message based,event driven 。也就是说 win32程序的运行是依靠外部不断发生的事件来驱动的,也就是说，程序不断等待（类似于有一个while循环）,等待任何可能的进入，然后做判断，在做适当的处理。因此win32程序只需要做好如下几件事情就可以了： 定义窗口的外观; 定义当不同的事件发生时，程序该做什么样的反应(定义窗口处理函数); 写一个while循环，不断检测新事件的发生，将其发送给不同的窗口处理函数。 win32程序入口 WinMainmain 函数是一般C语言的程序入口int main(int args,char *argv[],char *envp[]) winMain是win32程序的程序入口int CALLBACK WinMain(_in HINSTANCE hInstance,_in HINSTANCE hPrevInstance, _in LPSTR lpCmdLine,_in int nCmdShow)","categories":[],"tags":[]},{"title":"c#ref与out关键字详解","slug":"c-sharp-ref-与-out-关键字","date":"2017-04-26T10:48:14.000Z","updated":"2017-06-25T03:30:48.784Z","comments":true,"path":"2017/04/26/c-sharp-ref-与-out-关键字/","link":"","permalink":"https://wang-yulong.github.io/2017/04/26/c-sharp-ref-与-out-关键字/","excerpt":"","text":"c#(sharp) Ref关键字与out关键字的相同点与不同点 相同点：方法的定义和调用都必须显示使用ref、out关键字。都会导致参数按引用传递。 不同点：传递给ref关键字的参数必须赋初始值，而out不用。out关键字会清空变量，即使变量已经赋值也不行，退出函数时所有out引用个变量都要赋值。 Ref关键字（主要用来传值）代码示例 static void Main(String []args) { int age = 10; RefAge(ref age); Console.WriteLine(&quot;我现在的年龄是{0}&quot;,age); Console.ReadKey(); } /// &lt;summary&gt; /// 得到当前年龄 /// &lt;/summary&gt; /// &lt;param name=&quot;age&quot;&gt;&lt;/param&gt; static void RefAge( ref int age) { age += 5; } 运行效果图 Out关键字（主要用来取值）解决了函数只能返回一个值的局限性代码示例/// &lt;summary&gt; /// 采用Out关键字根据当前年龄计算上一年的年龄和下一年的年龄 /// &lt;/summary&gt; /// &lt;param name=&quot;age&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;lastYearAge&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;nextYearAge&quot;&gt;&lt;/param&gt; static void OutAge(int age,out int lastYearAge,out int nextYearAge) { lastYearAge = age - 1; nextYearAge = age + 1; } static void Main(String []args) { int age = 10; // RefAge(ref age); int lastYearAge; int nextYearAge; OutAge(age, out lastYearAge,out nextYearAge); Console.WriteLine(&quot;我现在的年龄是{0}&quot;,age); Console.WriteLine(&quot;我明年的年龄是{0}&quot;, nextYearAge); Console.WriteLine(&quot;我去年的年龄是{0}&quot;, lastYearAge); Console.ReadKey(); } 运行效果图","categories":[],"tags":[]},{"title":"Markdown常见语法","slug":"hexo1","date":"2017-04-15T07:28:19.000Z","updated":"2017-04-26T10:31:07.576Z","comments":true,"path":"2017/04/15/hexo1/","link":"","permalink":"https://wang-yulong.github.io/2017/04/15/hexo1/","excerpt":"","text":"注意事项 hexo 写博客 ，标题title部分必须位于md文件的最上方，否则会报一些莫名其妙的错误。 加粗，斜体哈哈哈(“哈哈哈“) 12342343 有序列表 列表项1 列表2 列表3 无序列表 无序1 无序2 无序3 引用 这个是一个引用 链接普通链接链接测试 行内链接This is an example inline link. This link has no title attribute. 参考式我经常去的几个网站百度、Leanote以及自己的博客Leanote 笔记是一个不错的网站。 相对路径See my About page for details 自动链接http://example.com/ &#97;&#100;&#x64;&#114;&#101;&#x73;&#115;&#x40;&#x31;&#x34;&#50;&#x35;&#50;&#50;&#54;&#x34;&#x36;&#x36;&#x40;&#x71;&#113;&#46;&#99;&#x6f;&#109; 锚点(没实现)跳转到注意事项 Markdown: 轻量级文本标记语言，可以转换成html，pdf等格式（左侧有一个可见的冒号和四个不可见的空格）代码块 2: 这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格） 代码块（左侧有八个不可见的空格） 阅读的方法: 打开书本。打开电灯。 &lt;代码写在这&gt; 转义##32343 注脚使用 Markdown^1可以效率的书写文档, 直接转换成 HTML[^2] , 你可以使用 Leanote^Le 编辑器进行书写。 [^2]:HyperText Markup Language 超文本标记语言 图片网页版 本地图片 分割线 表格 Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 代码块单行代码 MessageBox.Show(&quot;单行代码&quot;); 单行（行内式）代码C语言里的函数 scanf() 怎么使用？ 缩进式缩进 4 个空格或是 1 个制表符 一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。 #include &lt;stdio.h&gt; int main(void) { printf(&quot;Hello world\\n&quot;); } 多行代码12345#include &lt;stdio.h&gt;int main(void)&#123; printf(\"Hello world\\n\");&#125; html 代码可以直接解析 值班人员 星期一 星期二 星期三 李强 张明 王平","categories":[],"tags":[]}]}