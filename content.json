{"meta":{"title":"一人静在书中","subtitle":null,"description":"莫等闲,白了少年头","author":"Bob","url":"https://wang-yulong.github.io"},"pages":[{"title":"about","date":"2017-04-15T00:23:56.000Z","updated":"2017-04-15T00:23:56.097Z","comments":true,"path":"about/index.html","permalink":"https://wang-yulong.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2017-04-15T00:24:32.000Z","updated":"2017-04-15T00:24:32.959Z","comments":true,"path":"categories/index.html","permalink":"https://wang-yulong.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-04-15T00:25:40.000Z","updated":"2017-04-15T00:25:40.583Z","comments":true,"path":"tags/index.html","permalink":"https://wang-yulong.github.io/tags/index.html","excerpt":"","text":""},{"title":"win32 程序开发流程","date":"2017-04-28T04:46:09.000Z","updated":"2017-04-28T04:46:09.364Z","comments":true,"path":"win32-程序开发流程/index.html","permalink":"https://wang-yulong.github.io/win32-程序开发流程/index.html","excerpt":"","text":""}],"posts":[{"title":"c#按F5不能编译的问题以及C#平台和目标平台的区别","slug":"c-按F5不能编译的问题","date":"2017-05-04T07:42:40.000Z","updated":"2017-05-04T08:06:31.491Z","comments":true,"path":"2017/05/04/c-按F5不能编译的问题/","link":"","permalink":"https://wang-yulong.github.io/2017/05/04/c-按F5不能编译的问题/","excerpt":"","text":"1:c# 按F5不能编译的问题 在解决方案上右键-》配置管理器：如图 在此处可以配置F5调试运行的时候，是否生成某个项目； 2:平台和目标平台的区别 平台（是相对于整个解决方案来说的） 1.整个解决生成的时候默认只生成当前平台下的项目(如图) 2.当前也可以在AnyCpu下生成x86的项目（不推荐，编译时会有好多提醒） 3.当前项目-》属性-》生成–》平台–》只有一个可选项时，可以在解决方案右键-》配置管理器（添加新平台）如图 目标平台（是指你的程序可以在那个平台上运行） 1.如果在x86生成(程序可以在32位机以及64位上运行)，之所以这样，是因为windows平台的向下兼容性； 2.x64(程序可以在32位机和64位机上运行) 3.anycpu(程序可以在32位机器和64机器上运行)","categories":[],"tags":[]},{"title":"win32 程序开发流程","slug":"win32-程序开发流程","date":"2017-04-28T04:47:34.000Z","updated":"2017-04-28T05:25:34.518Z","comments":true,"path":"2017/04/28/win32-程序开发流程/","link":"","permalink":"https://wang-yulong.github.io/2017/04/28/win32-程序开发流程/","excerpt":"","text":"win32程序开发流程win32特点（message based–基于消息） (event driven–事件驱动) win32程序是message based,event driven 。也就是说 win32程序的运行是依靠外部不断发生的事件来驱动的,也就是说，程序不断等待（类似于有一个while循环）,等待任何可能的进入，然后做判断，在做适当的处理。因此win32程序只需要做好如下几件事情就可以了： 定义窗口的外观; 定义当不同的事件发生时，程序该做什么样的反应(定义窗口处理函数); 写一个while循环，不断检测新事件的发生，将其发送给不同的窗口处理函数。 win32程序入口 WinMainmain 函数是一般C语言的程序入口int main(int args,char *argv[],char *envp[]) winMain是win32程序的程序入口int CALLBACK WinMain(_in HINSTANCE hInstance,_in HINSTANCE hPrevInstance, _in LPSTR lpCmdLine,_in int nCmdShow)","categories":[],"tags":[]},{"title":"c#ref与out关键字详解","slug":"c-sharp-ref-与-out-关键字","date":"2017-04-26T10:48:14.000Z","updated":"2017-04-26T11:17:04.126Z","comments":true,"path":"2017/04/26/c-sharp-ref-与-out-关键字/","link":"","permalink":"https://wang-yulong.github.io/2017/04/26/c-sharp-ref-与-out-关键字/","excerpt":"","text":"c# Ref关键字与out关键字的相同点与不同点 相同点：方法的定义和调用都必须显示使用ref、out关键字。都会导致参数按引用传递。 不同点：传递给ref关键字的参数必须赋初始值，而out不用。out关键字会清空变量，即使变量已经赋值也不行，退出函数时所有out引用个变量都要赋值。 Ref关键字（主要用来传值）代码示例 static void Main(String []args) { int age = 10; RefAge(ref age); Console.WriteLine(&quot;我现在的年龄是{0}&quot;,age); Console.ReadKey(); } /// &lt;summary&gt; /// 得到当前年龄 /// &lt;/summary&gt; /// &lt;param name=&quot;age&quot;&gt;&lt;/param&gt; static void RefAge( ref int age) { age += 5; } 运行效果图 Out关键字（主要用来取值）解决了函数只能返回一个值的局限性代码示例/// &lt;summary&gt; /// 采用Out关键字根据当前年龄计算上一年的年龄和下一年的年龄 /// &lt;/summary&gt; /// &lt;param name=&quot;age&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;lastYearAge&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;nextYearAge&quot;&gt;&lt;/param&gt; static void OutAge(int age,out int lastYearAge,out int nextYearAge) { lastYearAge = age - 1; nextYearAge = age + 1; } static void Main(String []args) { int age = 10; // RefAge(ref age); int lastYearAge; int nextYearAge; OutAge(age, out lastYearAge,out nextYearAge); Console.WriteLine(&quot;我现在的年龄是{0}&quot;,age); Console.WriteLine(&quot;我明年的年龄是{0}&quot;, nextYearAge); Console.WriteLine(&quot;我去年的年龄是{0}&quot;, lastYearAge); Console.ReadKey(); } 运行效果图","categories":[],"tags":[]},{"title":"Markdown常见语法","slug":"hexo1","date":"2017-04-15T07:28:19.000Z","updated":"2017-04-26T10:31:07.576Z","comments":true,"path":"2017/04/15/hexo1/","link":"","permalink":"https://wang-yulong.github.io/2017/04/15/hexo1/","excerpt":"","text":"注意事项 hexo 写博客 ，标题title部分必须位于md文件的最上方，否则会报一些莫名其妙的错误。 加粗，斜体哈哈哈(“哈哈哈“) 12342343 有序列表 列表项1 列表2 列表3 无序列表 无序1 无序2 无序3 引用 这个是一个引用 链接普通链接链接测试 行内链接This is an example inline link. This link has no title attribute. 参考式我经常去的几个网站百度、Leanote以及自己的博客Leanote 笔记是一个不错的网站。 相对路径See my About page for details 自动链接http://example.com/ &#97;&#100;&#x64;&#114;&#101;&#x73;&#115;&#x40;&#x31;&#52;&#x32;&#53;&#50;&#x32;&#54;&#x34;&#x36;&#54;&#64;&#113;&#x71;&#46;&#x63;&#x6f;&#109; 锚点(没实现)跳转到注意事项 Markdown: 轻量级文本标记语言，可以转换成html，pdf等格式（左侧有一个可见的冒号和四个不可见的空格）代码块 2: 这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格） 代码块（左侧有八个不可见的空格） 阅读的方法: 打开书本。打开电灯。 &lt;代码写在这&gt; 转义##32343 注脚使用 Markdown^1可以效率的书写文档, 直接转换成 HTML[^2] , 你可以使用 Leanote^Le 编辑器进行书写。 [^2]:HyperText Markup Language 超文本标记语言 图片网页版 本地图片 分割线 表格 Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 代码块单行代码 MessageBox.Show(&quot;单行代码&quot;); 单行（行内式）代码C语言里的函数 scanf() 怎么使用？ 缩进式缩进 4 个空格或是 1 个制表符 一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。 #include &lt;stdio.h&gt; int main(void) { printf(&quot;Hello world\\n&quot;); } 多行代码12345#include &lt;stdio.h&gt;int main(void)&#123; printf(&quot;Hello world\\n&quot;);&#125; html 代码可以直接解析 值班人员 星期一 星期二 星期三 李强 张明 王平","categories":[],"tags":[]}]}