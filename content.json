{"meta":{"title":"一人静在书中","subtitle":null,"description":"莫等闲,白了少年头","author":"Bob","url":"https://wang-yulong.github.io"},"pages":[{"title":"categories","date":"2017-04-15T00:24:32.000Z","updated":"2017-04-15T00:24:32.959Z","comments":true,"path":"categories/index.html","permalink":"https://wang-yulong.github.io/categories/index.html","excerpt":"","text":""},{"title":"win32 程序开发流程","date":"2017-04-28T04:46:09.000Z","updated":"2017-04-28T04:46:09.364Z","comments":true,"path":"win32-程序开发流程/index.html","permalink":"https://wang-yulong.github.io/win32-程序开发流程/index.html","excerpt":"","text":""},{"title":"about","date":"2017-04-15T00:23:56.000Z","updated":"2017-04-15T00:23:56.097Z","comments":true,"path":"about/index.html","permalink":"https://wang-yulong.github.io/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-04-15T00:25:40.000Z","updated":"2017-04-15T00:25:40.583Z","comments":true,"path":"tags/index.html","permalink":"https://wang-yulong.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"'JavaWeb(开发微信公众账号)微信开发遇到的问题'","slug":"微信开发遇到的问题","date":"2017-06-20T12:22:54.000Z","updated":"2017-06-20T12:32:38.299Z","comments":true,"path":"2017/06/20/微信开发遇到的问题/","link":"","permalink":"https://wang-yulong.github.io/2017/06/20/微信开发遇到的问题/","excerpt":"","text":"1：回复消息老是提示”该公众号暂时无法提供服务，请稍后再试”查了好久，发现并不是网上说的返回值为空的为题，而是web.xml中 servelt的映射路径写错了。。如图所示","categories":[],"tags":[]},{"title":"C#_封装之（List与Dictionary）","slug":"C-sharp封装（List与Dictionary）","date":"2017-06-09T12:30:43.000Z","updated":"2017-06-09T12:45:20.226Z","comments":true,"path":"2017/06/09/C-sharp封装（List与Dictionary）/","link":"","permalink":"https://wang-yulong.github.io/2017/06/09/C-sharp封装（List与Dictionary）/","excerpt":"","text":"#简单描述 KeyedList： 同时实现IDictionary和IList接口的集合。 带有索引的List使用上会比较方便，可以通过Key来索引Value。 同时内部是线性存储的，可以保证顺序，可以使用下标访问数据。 内部使用Dictionary来存储Key到Value的映射， List存储KeyValuePair。有很大的冗余，可以参考（小规模的数据用着还是比较方便的） 代码： [Serializable] [Obsolete(&quot;未完善，有冗余&quot;)] public sealed class KeyedList&lt;TKey, TValue&gt; : IDictionary&lt;TKey, TValue&gt;, IList&lt;KeyValuePair&lt;TKey, TValue&gt;&gt; { private readonly Dictionary&lt;TKey, TValue&gt; _dict = new Dictionary&lt;TKey, TValue&gt;(); private readonly List&lt;KeyValuePair&lt;TKey, TValue&gt;&gt; _list = new List&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;(); /// &lt;summary&gt; /// Returns false. /// &lt;/summary&gt; public bool IsReadOnly { get { return false; } } /// &lt;summary&gt; /// Returns the number of entries in the KeyedList. /// &lt;/summary&gt; public int Count { get { return _list.Count; } } /// &lt;summary&gt; /// Get/Set the value at the specified index. /// &lt;/summary&gt; /// &lt;param name=&quot;index&quot;&gt;The index.&lt;/param&gt; /// &lt;returns&gt;The value.&lt;/returns&gt; public KeyValuePair&lt;TKey, TValue&gt; this[int index] { get { if (index &lt; 0 || index &gt;= Count) { throw new ArgumentOutOfRangeException(&quot;index&quot;); } return _list[index]; } set { if (index &lt; 0 || index &gt;= Count) { throw new ArgumentOutOfRangeException(&quot;index&quot;); } _list[index] = value; _dict[value.Key] = value.Value; } } /// &lt;summary&gt; /// Get/Set the value associated with the specified key. /// &lt;/summary&gt; /// &lt;param name=&quot;key&quot;&gt;The key.&lt;/param&gt; /// &lt;returns&gt;The associated value.&lt;/returns&gt; public TValue this[TKey key] { get { return _dict[key]; } set { if (_dict.ContainsKey(key)) { _dict[key] = value; _list[IndexOf(key)] = new KeyValuePair&lt;TKey, TValue&gt;(key, value); } else { Add(key, value); } } } /// &lt;summary&gt; /// Get an unordered list of keys. /// This collection refers back to the keys in the original Dictionary. /// &lt;/summary&gt; public ICollection&lt;TKey&gt; Keys { get { return _dict.Keys; } } /// &lt;summary&gt; /// Get an unordered list of values. /// This collection refers back to the values in the original Dictionary. /// &lt;/summary&gt; public ICollection&lt;TValue&gt; Values { get { return _dict.Values; } } /// &lt;summary&gt; /// Get the ordered list of keys. /// This is a copy of the keys in the original Dictionary. /// &lt;/summary&gt; public List&lt;TKey&gt; OrderedKeys { get { List&lt;TKey&gt; retList = new List&lt;TKey&gt;(); foreach (KeyValuePair&lt;TKey, TValue&gt; kvp in _list) { retList.Add(kvp.Key); } return retList; } } /// &lt;summary&gt; /// Get the ordered list of values. /// This is a copy of the values in the original Dictionary. /// &lt;/summary&gt; public List&lt;TValue&gt; OrderedValues { get { List&lt;TValue&gt; retList = new List&lt;TValue&gt;(); foreach (KeyValuePair&lt;TKey, TValue&gt; kvp in _list) { retList.Add(kvp.Value); } return retList; } } /// &lt;summary&gt; /// Returns the key at the specified index. /// &lt;/summary&gt; /// &lt;param name=&quot;idx&quot;&gt;The index.&lt;/param&gt; /// &lt;returns&gt;The key at the index.&lt;/returns&gt; public TKey GetKey(int idx) { if (idx &lt; 0 || idx &gt;= Count) { throw new ArgumentOutOfRangeException(&quot;index&quot;); } return _list[idx].Key; } /// &lt;summary&gt; /// Returns the value at the specified index. /// &lt;/summary&gt; /// &lt;param name=&quot;idx&quot;&gt;The index.&lt;/param&gt; /// &lt;returns&gt;The value at the index.&lt;/returns&gt; public TValue GetValue(int idx) { if (idx &lt; 0 || idx &gt;= Count) { throw new ArgumentOutOfRangeException(&quot;index&quot;); } return _list[idx].Value; } /// &lt;summary&gt; /// Get the index of a particular key. /// &lt;/summary&gt; /// &lt;param name=&quot;key&quot;&gt;The key to find the index of.&lt;/param&gt; /// &lt;returns&gt;The index of the key, or -1 if not found.&lt;/returns&gt; public int IndexOf(TKey key) { int ret = -1; for (int i = 0; i &lt; _list.Count; i++) { if (_list[i].Key.Equals(key)) { ret = i; break; } } return ret; } /// &lt;summary&gt; /// Given the key-value pair, find the index. /// &lt;/summary&gt; /// &lt;param name=&quot;kvp&quot;&gt;The key-value pair.&lt;/param&gt; /// &lt;returns&gt;The index, or -1 if not found.&lt;/returns&gt; public int IndexOf(KeyValuePair&lt;TKey, TValue&gt; kvp) { return IndexOf(kvp.Key); } /// &lt;summary&gt; /// Gets the Dictionary class backing the KeyedList. /// &lt;/summary&gt; public Dictionary&lt;TKey, TValue&gt; ObjectTable { get { return _dict; } } /// &lt;summary&gt; /// Clears all entries in the KeyedList. /// &lt;/summary&gt; public void Clear() { _dict.Clear(); _list.Clear(); } /// &lt;summary&gt; /// Test if the KeyedList contains the key. /// &lt;/summary&gt; /// &lt;param name=&quot;key&quot;&gt;The key.&lt;/param&gt; /// &lt;returns&gt;True if the key is found.&lt;/returns&gt; public bool ContainsKey(TKey key) { return _dict.ContainsKey(key); } /// &lt;summary&gt; /// Test if the KeyedList contains the key in the key-value pair. /// &lt;/summary&gt; /// &lt;param name=&quot;kvp&quot;&gt;The key-value pair.&lt;/param&gt; /// &lt;returns&gt;True if the key is found.&lt;/returns&gt; public bool Contains(KeyValuePair&lt;TKey, TValue&gt; kvp) { return _dict.ContainsKey(kvp.Key); } /// &lt;summary&gt; /// Adds a key-value pair to the KeyedList. /// &lt;/summary&gt; /// &lt;param name=&quot;key&quot;&gt;The key.&lt;/param&gt; /// &lt;param name=&quot;value&quot;&gt;The associated value.&lt;/param&gt; public void Add(TKey key, TValue value) { _dict.Add(key, value); _list.Add(new KeyValuePair&lt;TKey, TValue&gt;(key, value)); } /// &lt;summary&gt; /// Adds a key-value pair to the KeyedList. /// &lt;/summary&gt; /// &lt;param name=&quot;kvp&quot;&gt;The KeyValuePair instance.&lt;/param&gt; public void Add(KeyValuePair&lt;TKey, TValue&gt; kvp) { Add(kvp.Key, kvp.Value); } /// &lt;summary&gt; /// Copy the entire key-value pairs to the KeyValuePair array, starting /// at the specified index of the target array. The array is populated /// as an ordered list. /// &lt;/summary&gt; /// &lt;param name=&quot;kvpa&quot;&gt;The KeyValuePair array.&lt;/param&gt; /// &lt;param name=&quot;idx&quot;&gt;The position to start the copy.&lt;/param&gt; public void CopyTo(KeyValuePair&lt;TKey, TValue&gt;[] kvpa, int idx) { _list.CopyTo(kvpa, idx); } /// &lt;summary&gt; /// Insert the key-value at the specified index. /// &lt;/summary&gt; /// &lt;param name=&quot;idx&quot;&gt;The zero-based insert point.&lt;/param&gt; /// &lt;param name=&quot;key&quot;&gt;The key.&lt;/param&gt; /// &lt;param name=&quot;value&quot;&gt;The value.&lt;/param&gt; public void Insert(int idx, TKey key, TValue value) { if ((idx &lt; 0) || (idx &gt; Count)) { throw new ArgumentOutOfRangeException(&quot;index&quot;); } _dict.Add(key, value); _list.Insert(idx, new KeyValuePair&lt;TKey, TValue&gt;(key, value)); } /// &lt;summary&gt; /// Insert the key-value pair at the specified index location. /// &lt;/summary&gt; /// &lt;param name=&quot;idx&quot;&gt;The key.&lt;/param&gt; /// &lt;param name=&quot;kvp&quot;&gt;The value.&lt;/param&gt; public void Insert(int idx, KeyValuePair&lt;TKey, TValue&gt; kvp) { if ((idx &lt; 0) || (idx &gt; Count)) { throw new ArgumentOutOfRangeException(&quot;index&quot;); } _dict.Add(kvp.Key, kvp.Value); _list.Insert(idx, kvp); } /// &lt;summary&gt; /// Remove the entry. /// &lt;/summary&gt; /// &lt;param name=&quot;key&quot;&gt;The key identifying the key-value pair.&lt;/param&gt; /// &lt;returns&gt;True if removed.&lt;/returns&gt; public bool Remove(TKey key) { bool found = _dict.Remove(key); if (found) { _list.RemoveAt(IndexOf(key)); } return found; } /// &lt;summary&gt; /// Remove the key in the specified KeyValuePair instance. The Value /// property is ignored. /// &lt;/summary&gt; /// &lt;param name=&quot;kvp&quot;&gt;The key-value identifying the entry.&lt;/param&gt; /// &lt;returns&gt;True if removed.&lt;/returns&gt; public bool Remove(KeyValuePair&lt;TKey, TValue&gt; kvp) { return Remove(kvp.Key); } /// &lt;summary&gt; /// Remove the entry at the specified index. /// &lt;/summary&gt; /// &lt;param name=&quot;idx&quot;&gt;The index to the entry to be removed.&lt;/param&gt; public void RemoveAt(int idx) { if ((idx &lt; 0) || (idx &gt;= Count)) { throw new ArgumentOutOfRangeException(&quot;index&quot;); } _dict.Remove(_list[idx].Key); _list.RemoveAt(idx); } /// &lt;summary&gt; /// Attempt to get the value, given the key, without throwing an exception if not found. /// &lt;/summary&gt; /// &lt;param name=&quot;key&quot;&gt;The key indentifying the entry.&lt;/param&gt; /// &lt;param name=&quot;val&quot;&gt;The value, if found.&lt;/param&gt; /// &lt;returns&gt;True if found.&lt;/returns&gt; public bool TryGetValue(TKey key, out TValue val) { return _dict.TryGetValue(key, out val); } /// &lt;summary&gt; /// Returns an ordered System.Collections KeyValuePair objects. /// &lt;/summary&gt; IEnumerator IEnumerable.GetEnumerator() { return _list.GetEnumerator(); } /// &lt;summary&gt; /// Returns an ordered KeyValuePair enumerator. /// &lt;/summary&gt; IEnumerator&lt;KeyValuePair&lt;TKey, TValue&gt;&gt; IEnumerable&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;.GetEnumerator() { return _list.GetEnumerator(); } }","categories":[],"tags":[]},{"title":"c# GDI测量某个点在某个不规则路径上或路径中","slug":"c-测量类","date":"2017-05-23T07:07:36.000Z","updated":"2017-05-23T07:35:38.225Z","comments":true,"path":"2017/05/23/c-测量类/","link":"","permalink":"https://wang-yulong.github.io/2017/05/23/c-测量类/","excerpt":"","text":"#测量某个点是否在不规则路径上 1：对路径进行克隆（防止当前的操作影响所要渲染的路径）bool isExist=false; var path = (GraphicsPath)_path.Clone(); 2： 创建Matrix对象（3*3的矩阵），用来对该路径进行平移（TransLate），缩放（Scale），旋转（Rotate） Matrix matrix = new Matrix(); matrix.Translate(this.Location.X, this.Location.Y); path.Transform(matrix); 3:用画笔为路径增加轮廓（因为GraphicsPath本来起始是没有空间，也就无从谈起是否落在该路径上）using (var pen = new Pen(Color.FromArgb(0, 153, 229), 6)) { path.Widen(pen); } 4：判断改点是否在路径上if (path.IsVisible(pt)) { isExist = true; } 通过以上4步便可以知道某个点是不是在不规则路径上 测量某个点是否在不规则路径中## GraphicsPath path = new GraphicsPath(); // 指示由矩形和由路径构成的图形形状的内部。无法继承此类。 Region myRegion = new Region(); myGraphicsPath.Reset(); Point inputpoint1 = new Point(inputx1, inputy1); Point inputpoint2 = new Point(inputx2, inputy2); myGraphicsPath.AddPolygon(inputpoint1); myGraphicsPath.AddPolygon(inputpoint2); myRegion.MakeEmpty(); myRegion.Union(myGraphicsPath); //返回判断点是否在不规则路径中 bool result= myRegion.IsVisible(inputponint);","categories":[],"tags":[]},{"title":"c# invoke和BeginInvoke 细节收录","slug":"c-invoke和BeginInvoke-细节收录","date":"2017-05-05T12:34:08.000Z","updated":"2017-05-24T12:53:21.713Z","comments":true,"path":"2017/05/05/c-invoke和BeginInvoke-细节收录/","link":"","permalink":"https://wang-yulong.github.io/2017/05/05/c-invoke和BeginInvoke-细节收录/","excerpt":"","text":"Invoke MSDN的解释 在拥有此控件的基础窗口句柄的线程上执行指定的委托 自我理解 （1）同步的，必须得等委托内的代码执行完成之后才能执行 BeginInvoke MSDN的解释 在创建控件的基础句柄所在线程上异步执行指定委托。 自我理解 （1）异步的，不一定非得等委托内的代码运行结束才执行 个人实例 如图所示，创建一个父窗口，在父窗口中点击按钮弹出一个新的子窗口Form6; 在子窗口添加按钮点击的时候执行关闭操作（this.Close），同时用根窗口所在的Form弹出另一个Form; 如果使用Invoke会阻止this.Close的执行； 如果使用BeginInvoke的话则不会； ##多线程场景 ###1：Form关闭的时候回到主线程去弹窗（这有这样才可以） EventHandler actionDelegate = delegate { _signInAlertForm.Close(); }; mainTreadForm.BeginInvoke(actionDelegate, &quot;&quot;);//主线程对应的Form } ###2：计时器结束的时候想去关掉Form,但是计时器会单独新启动一个线程，此时需要回到创建该控件的线程去执行某个操作(测试这两种都可以) EventHandler actionDelegate = delegate { _signInAlertForm.Hide(); }; this._signInAlertForm.BeginInvoke(actionDelegate, &quot;&quot;); this._signInAlertForm.Invoke(actionDelegate, &quot;&quot;); }","categories":[],"tags":[]},{"title":"c#按F5不能编译的问题以及C#平台和目标平台的区别","slug":"c-按F5不能编译的问题","date":"2017-05-04T07:42:40.000Z","updated":"2017-05-04T08:06:31.491Z","comments":true,"path":"2017/05/04/c-按F5不能编译的问题/","link":"","permalink":"https://wang-yulong.github.io/2017/05/04/c-按F5不能编译的问题/","excerpt":"","text":"1:c# 按F5不能编译的问题 在解决方案上右键-》配置管理器：如图 在此处可以配置F5调试运行的时候，是否生成某个项目； 2:平台和目标平台的区别 平台（是相对于整个解决方案来说的） 1.整个解决生成的时候默认只生成当前平台下的项目(如图) 2.当前也可以在AnyCpu下生成x86的项目（不推荐，编译时会有好多提醒） 3.当前项目-》属性-》生成–》平台–》只有一个可选项时，可以在解决方案右键-》配置管理器（添加新平台）如图 目标平台（是指你的程序可以在那个平台上运行） 1.如果在x86生成(程序可以在32位机以及64位上运行)，之所以这样，是因为windows平台的向下兼容性； 2.x64(程序可以在32位机和64位机上运行) 3.anycpu(程序可以在32位机器和64机器上运行)","categories":[],"tags":[]},{"title":"win32 程序开发流程","slug":"win32-程序开发流程","date":"2017-04-28T04:47:34.000Z","updated":"2017-04-28T05:25:34.518Z","comments":true,"path":"2017/04/28/win32-程序开发流程/","link":"","permalink":"https://wang-yulong.github.io/2017/04/28/win32-程序开发流程/","excerpt":"","text":"win32程序开发流程win32特点（message based–基于消息） (event driven–事件驱动) win32程序是message based,event driven 。也就是说 win32程序的运行是依靠外部不断发生的事件来驱动的,也就是说，程序不断等待（类似于有一个while循环）,等待任何可能的进入，然后做判断，在做适当的处理。因此win32程序只需要做好如下几件事情就可以了： 定义窗口的外观; 定义当不同的事件发生时，程序该做什么样的反应(定义窗口处理函数); 写一个while循环，不断检测新事件的发生，将其发送给不同的窗口处理函数。 win32程序入口 WinMainmain 函数是一般C语言的程序入口int main(int args,char *argv[],char *envp[]) winMain是win32程序的程序入口int CALLBACK WinMain(_in HINSTANCE hInstance,_in HINSTANCE hPrevInstance, _in LPSTR lpCmdLine,_in int nCmdShow)","categories":[],"tags":[]},{"title":"c#ref与out关键字详解","slug":"c-sharp-ref-与-out-关键字","date":"2017-04-26T10:48:14.000Z","updated":"2017-04-26T11:17:04.126Z","comments":true,"path":"2017/04/26/c-sharp-ref-与-out-关键字/","link":"","permalink":"https://wang-yulong.github.io/2017/04/26/c-sharp-ref-与-out-关键字/","excerpt":"","text":"c# Ref关键字与out关键字的相同点与不同点 相同点：方法的定义和调用都必须显示使用ref、out关键字。都会导致参数按引用传递。 不同点：传递给ref关键字的参数必须赋初始值，而out不用。out关键字会清空变量，即使变量已经赋值也不行，退出函数时所有out引用个变量都要赋值。 Ref关键字（主要用来传值）代码示例 static void Main(String []args) { int age = 10; RefAge(ref age); Console.WriteLine(&quot;我现在的年龄是{0}&quot;,age); Console.ReadKey(); } /// &lt;summary&gt; /// 得到当前年龄 /// &lt;/summary&gt; /// &lt;param name=&quot;age&quot;&gt;&lt;/param&gt; static void RefAge( ref int age) { age += 5; } 运行效果图 Out关键字（主要用来取值）解决了函数只能返回一个值的局限性代码示例/// &lt;summary&gt; /// 采用Out关键字根据当前年龄计算上一年的年龄和下一年的年龄 /// &lt;/summary&gt; /// &lt;param name=&quot;age&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;lastYearAge&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;nextYearAge&quot;&gt;&lt;/param&gt; static void OutAge(int age,out int lastYearAge,out int nextYearAge) { lastYearAge = age - 1; nextYearAge = age + 1; } static void Main(String []args) { int age = 10; // RefAge(ref age); int lastYearAge; int nextYearAge; OutAge(age, out lastYearAge,out nextYearAge); Console.WriteLine(&quot;我现在的年龄是{0}&quot;,age); Console.WriteLine(&quot;我明年的年龄是{0}&quot;, nextYearAge); Console.WriteLine(&quot;我去年的年龄是{0}&quot;, lastYearAge); Console.ReadKey(); } 运行效果图","categories":[],"tags":[]},{"title":"Markdown常见语法","slug":"hexo1","date":"2017-04-15T07:28:19.000Z","updated":"2017-04-26T10:31:07.576Z","comments":true,"path":"2017/04/15/hexo1/","link":"","permalink":"https://wang-yulong.github.io/2017/04/15/hexo1/","excerpt":"","text":"注意事项 hexo 写博客 ，标题title部分必须位于md文件的最上方，否则会报一些莫名其妙的错误。 加粗，斜体哈哈哈(“哈哈哈“) 12342343 有序列表 列表项1 列表2 列表3 无序列表 无序1 无序2 无序3 引用 这个是一个引用 链接普通链接链接测试 行内链接This is an example inline link. This link has no title attribute. 参考式我经常去的几个网站百度、Leanote以及自己的博客Leanote 笔记是一个不错的网站。 相对路径See my About page for details 自动链接http://example.com/ &#97;&#x64;&#x64;&#114;&#101;&#115;&#x73;&#64;&#49;&#x34;&#x32;&#x35;&#50;&#x32;&#54;&#52;&#x36;&#x36;&#x40;&#x71;&#x71;&#x2e;&#99;&#111;&#x6d; 锚点(没实现)跳转到注意事项 Markdown: 轻量级文本标记语言，可以转换成html，pdf等格式（左侧有一个可见的冒号和四个不可见的空格）代码块 2: 这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格） 代码块（左侧有八个不可见的空格） 阅读的方法: 打开书本。打开电灯。 &lt;代码写在这&gt; 转义##32343 注脚使用 Markdown^1可以效率的书写文档, 直接转换成 HTML[^2] , 你可以使用 Leanote^Le 编辑器进行书写。 [^2]:HyperText Markup Language 超文本标记语言 图片网页版 本地图片 分割线 表格 Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 代码块单行代码 MessageBox.Show(&quot;单行代码&quot;); 单行（行内式）代码C语言里的函数 scanf() 怎么使用？ 缩进式缩进 4 个空格或是 1 个制表符 一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。 #include &lt;stdio.h&gt; int main(void) { printf(&quot;Hello world\\n&quot;); } 多行代码12345#include &lt;stdio.h&gt;int main(void)&#123; printf(&quot;Hello world\\n&quot;);&#125; html 代码可以直接解析 值班人员 星期一 星期二 星期三 李强 张明 王平","categories":[],"tags":[]}]}